(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([[6],{

/***/ "./node_modules/scroll-behavior-polyfill/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/scroll-behavior-polyfill/dist/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function () {\n    'use strict';\n\n    var UNSUPPORTED_ENVIRONMENT = typeof window === \"undefined\";\n\n    /**\n     * Is true if the browser natively supports the 'scroll-behavior' CSS-property.\n     * @type {boolean}\n     */\n    var SUPPORTS_SCROLL_BEHAVIOR = UNSUPPORTED_ENVIRONMENT ? false : \"scrollBehavior\" in document.documentElement.style;\n\n    \n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\r\n\r\n    function __read(o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    }\n\n    function getScrollingElement() {\n        if (document.scrollingElement != null) {\n            return document.scrollingElement;\n        }\n        else {\n            return document.documentElement;\n        }\n    }\n\n    var STYLE_ATTRIBUTE_PROPERTY_NAME = \"scroll-behavior\";\n    var STYLE_ATTRIBUTE_PROPERTY_REGEXP = new RegExp(STYLE_ATTRIBUTE_PROPERTY_NAME + \":\\\\s*([^;]*)\");\n    /**\n     * Given an Element, this function appends the given ScrollBehavior CSS property value to the elements' 'style' attribute.\n     * If it doesnt already have one, it will add it.\n     * @param {Element} element\n     * @param {ScrollBehavior} behavior\n     */\n    function appendScrollBehaviorToStyleAttribute(element, behavior) {\n        var addition = STYLE_ATTRIBUTE_PROPERTY_NAME + \":\" + behavior;\n        var attributeValue = element.getAttribute(\"style\");\n        if (attributeValue == null || attributeValue === \"\") {\n            element.setAttribute(\"style\", addition);\n            return;\n        }\n        // The style attribute may already include a 'scroll-behavior:<something>' in which case that should be replaced\n        var existingValueForProperty = parseScrollBehaviorFromStyleAttribute(element);\n        if (existingValueForProperty != null) {\n            var replacementProperty = STYLE_ATTRIBUTE_PROPERTY_NAME + \":\" + existingValueForProperty;\n            // Replace the variant that ends with a semi-colon which it may\n            attributeValue = attributeValue.replace(replacementProperty + \";\", \"\");\n            // Replace the variant that *doesn't* end with a semi-colon\n            attributeValue = attributeValue.replace(replacementProperty, \"\");\n        }\n        // Now, append the behavior to the string.\n        element.setAttribute(\"style\", attributeValue.endsWith(\";\") ? \"\" + attributeValue + addition : \";\" + attributeValue + addition);\n    }\n    /**\n     * Given an Element, this function attempts to parse its 'style' attribute (if it has one)' to extract\n     * a value for the 'scroll-behavior' CSS property (if it is given within that style attribute)\n     * @param {Element} element\n     * @returns {ScrollBehavior?}\n     */\n    function parseScrollBehaviorFromStyleAttribute(element) {\n        var styleAttributeValue = element.getAttribute(\"style\");\n        if (styleAttributeValue != null && styleAttributeValue.includes(STYLE_ATTRIBUTE_PROPERTY_NAME)) {\n            var match = styleAttributeValue.match(STYLE_ATTRIBUTE_PROPERTY_REGEXP);\n            if (match != null) {\n                var _a = __read(match, 2), behavior = _a[1];\n                if (behavior != null && behavior !== \"\") {\n                    return behavior;\n                }\n            }\n        }\n        return undefined;\n    }\n\n    var styleDeclarationPropertyName = \"scrollBehavior\";\n    /**\n     * Determines the scroll behavior to use, depending on the given ScrollOptions and the position of the Element\n     * within the DOM\n     * @param {Element|HTMLElement|Window} inputTarget\n     * @param {ScrollOptions} [options]\n     * @returns {ScrollBehavior}\n     */\n    function getScrollBehavior(inputTarget, options) {\n        // If the given 'behavior' is 'smooth', apply smooth scrolling no matter what\n        if (options != null && options.behavior === \"smooth\")\n            return \"smooth\";\n        var target = \"style\" in inputTarget ? inputTarget : getScrollingElement();\n        var value;\n        if (\"style\" in target) {\n            // Check if scroll-behavior is set as a property on the CSSStyleDeclaration\n            var scrollBehaviorPropertyValue = target.style[styleDeclarationPropertyName];\n            // Return it if it is given and has a proper value\n            if (scrollBehaviorPropertyValue != null && scrollBehaviorPropertyValue !== \"\") {\n                value = scrollBehaviorPropertyValue;\n            }\n        }\n        if (value == null) {\n            var attributeValue = target.getAttribute(\"scroll-behavior\");\n            if (attributeValue != null && attributeValue !== \"\") {\n                value = attributeValue;\n            }\n        }\n        if (value == null) {\n            // Otherwise, check if it is set as an inline style\n            value = parseScrollBehaviorFromStyleAttribute(target);\n        }\n        if (value == null) {\n            // Take the computed style for the element and see if it contains a specific 'scroll-behavior' value\n            var computedStyle = getComputedStyle(target);\n            var computedStyleValue = computedStyle.getPropertyValue(\"scrollBehavior\");\n            if (computedStyleValue != null && computedStyleValue !== \"\") {\n                value = computedStyleValue;\n            }\n        }\n        // In all other cases, use the value from the CSSOM\n        return value;\n    }\n\n    \n\n    \n\n    var HALF = 0.5;\n    /**\n     * The easing function to use when applying the smooth scrolling\n     * @param {number} k\n     * @returns {number}\n     */\n    function ease(k) {\n        return HALF * (1 - Math.cos(Math.PI * k));\n    }\n\n    var NOOP = {\n        reset: function () { }\n    };\n    var map = typeof WeakMap === \"undefined\" ? undefined : new WeakMap();\n    function disableScrollSnap(scroller) {\n        // If scroll-behavior is natively supported, or if there is no native WeakMap support, there's no need for this fix\n        if (SUPPORTS_SCROLL_BEHAVIOR || map == null) {\n            return NOOP;\n        }\n        var scrollingElement = getScrollingElement();\n        var cachedScrollSnapValue;\n        var cachedScrollBehaviorStyleAttributeValue;\n        var secondaryScroller;\n        var secondaryScrollerCachedScrollSnapValue;\n        var secondaryScrollerCachedScrollBehaviorStyleAttributeValue;\n        var existingResult = map.get(scroller);\n        if (existingResult != null) {\n            cachedScrollSnapValue = existingResult.cachedScrollSnapValue;\n            cachedScrollBehaviorStyleAttributeValue = existingResult.cachedScrollBehaviorStyleAttributeValue;\n            secondaryScroller = existingResult.secondaryScroller;\n            secondaryScrollerCachedScrollSnapValue = existingResult.secondaryScrollerCachedScrollSnapValue;\n            secondaryScrollerCachedScrollBehaviorStyleAttributeValue = existingResult.secondaryScrollerCachedScrollBehaviorStyleAttributeValue;\n            existingResult.release();\n        }\n        else {\n            cachedScrollSnapValue = scroller.style.scrollSnapType === \"\" ? null : scroller.style.scrollSnapType;\n            cachedScrollBehaviorStyleAttributeValue = parseScrollBehaviorFromStyleAttribute(scroller);\n            secondaryScroller = scroller === scrollingElement && scrollingElement !== document.body ? document.body : undefined;\n            secondaryScrollerCachedScrollSnapValue =\n                secondaryScroller == null ? undefined : secondaryScroller.style.scrollSnapType === \"\" ? null : secondaryScroller.style.scrollSnapType;\n            secondaryScrollerCachedScrollBehaviorStyleAttributeValue =\n                secondaryScroller == null ? undefined : parseScrollBehaviorFromStyleAttribute(secondaryScroller);\n            var cachedComputedScrollSnapValue = getComputedStyle(scroller).getPropertyValue(\"scroll-snap-type\");\n            var secondaryScrollerCachedComputedScrollSnapValue = secondaryScroller == null ? undefined : getComputedStyle(secondaryScroller).getPropertyValue(\"scroll-snap-type\");\n            // If it just so happens that there actually isn't any scroll snapping going on, there's no point in performing any additional work here.\n            if (cachedComputedScrollSnapValue === \"none\" && secondaryScrollerCachedComputedScrollSnapValue === \"none\") {\n                return NOOP;\n            }\n        }\n        scroller.style.scrollSnapType = \"none\";\n        if (secondaryScroller !== undefined) {\n            secondaryScroller.style.scrollSnapType = \"none\";\n        }\n        if (cachedScrollBehaviorStyleAttributeValue !== undefined) {\n            appendScrollBehaviorToStyleAttribute(scroller, cachedScrollBehaviorStyleAttributeValue);\n        }\n        if (secondaryScroller !== undefined && secondaryScrollerCachedScrollBehaviorStyleAttributeValue !== undefined) {\n            appendScrollBehaviorToStyleAttribute(secondaryScroller, secondaryScrollerCachedScrollBehaviorStyleAttributeValue);\n        }\n        var hasReleased = false;\n        var eventTarget = scroller === scrollingElement ? window : scroller;\n        function release() {\n            eventTarget.removeEventListener(\"scroll\", resetHandler);\n            if (map != null) {\n                map[\"delete\"](scroller);\n            }\n            hasReleased = true;\n        }\n        function resetHandler() {\n            scroller.style.scrollSnapType = cachedScrollSnapValue;\n            if (secondaryScroller != null && secondaryScrollerCachedScrollSnapValue !== undefined) {\n                secondaryScroller.style.scrollSnapType = secondaryScrollerCachedScrollSnapValue;\n            }\n            if (cachedScrollBehaviorStyleAttributeValue !== undefined) {\n                appendScrollBehaviorToStyleAttribute(scroller, cachedScrollBehaviorStyleAttributeValue);\n            }\n            if (secondaryScroller !== undefined && secondaryScrollerCachedScrollBehaviorStyleAttributeValue !== undefined) {\n                appendScrollBehaviorToStyleAttribute(secondaryScroller, secondaryScrollerCachedScrollBehaviorStyleAttributeValue);\n            }\n            release();\n        }\n        function reset() {\n            setTimeout(function () {\n                if (hasReleased)\n                    return;\n                eventTarget.addEventListener(\"scroll\", resetHandler);\n            });\n        }\n        map.set(scroller, {\n            release: release,\n            cachedScrollSnapValue: cachedScrollSnapValue,\n            cachedScrollBehaviorStyleAttributeValue: cachedScrollBehaviorStyleAttributeValue,\n            secondaryScroller: secondaryScroller,\n            secondaryScrollerCachedScrollSnapValue: secondaryScrollerCachedScrollSnapValue,\n            secondaryScrollerCachedScrollBehaviorStyleAttributeValue: secondaryScrollerCachedScrollBehaviorStyleAttributeValue\n        });\n        return {\n            reset: reset\n        };\n    }\n\n    /**\n     * The duration of a smooth scroll\n     * @type {number}\n     */\n    var SCROLL_TIME = 15000;\n    /**\n     * Performs a smooth repositioning of the scroll\n     * @param {ISmoothScrollOptions} options\n     */\n    function smoothScroll(options) {\n        var startTime = options.startTime, startX = options.startX, startY = options.startY, endX = options.endX, endY = options.endY, method = options.method, scroller = options.scroller;\n        var timeLapsed = 0;\n        var distanceX = endX - startX;\n        var distanceY = endY - startY;\n        var speed = Math.max(Math.abs((distanceX / 1000) * SCROLL_TIME), Math.abs((distanceY / 1000) * SCROLL_TIME));\n        // Temporarily disables any scroll snapping that may be active since it fights for control over the scroller with this polyfill\n        var scrollSnapFix = disableScrollSnap(scroller);\n        requestAnimationFrame(function animate(timestamp) {\n            timeLapsed += timestamp - startTime;\n            var percentage = Math.max(0, Math.min(1, speed === 0 ? 0 : timeLapsed / speed));\n            var positionX = Math.floor(startX + distanceX * ease(percentage));\n            var positionY = Math.floor(startY + distanceY * ease(percentage));\n            method(positionX, positionY);\n            if (positionX !== endX || positionY !== endY) {\n                requestAnimationFrame(animate);\n            }\n            else {\n                if (scrollSnapFix != null) {\n                    scrollSnapFix.reset();\n                    scrollSnapFix = undefined;\n                }\n            }\n        });\n    }\n\n    /**\n     * Returns a High Resolution timestamp if possible, otherwise fallbacks to Date.now()\n     * @returns {number}\n     */\n    function now() {\n        if (\"performance\" in window)\n            return performance.now();\n        return Date.now();\n    }\n\n    \n\n    var ELEMENT_ORIGINAL_SCROLL = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scroll;\n\n    var WINDOW_ORIGINAL_SCROLL = UNSUPPORTED_ENVIRONMENT ? undefined : window.scroll;\n\n    var ELEMENT_ORIGINAL_SCROLL_BY = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollBy;\n\n    var WINDOW_ORIGINAL_SCROLL_BY = UNSUPPORTED_ENVIRONMENT ? undefined : window.scrollBy;\n\n    var ELEMENT_ORIGINAL_SCROLL_TO = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollTo;\n\n    var WINDOW_ORIGINAL_SCROLL_TO = UNSUPPORTED_ENVIRONMENT ? undefined : window.scrollTo;\n\n    /**\n     * A fallback if Element.prototype.scroll is not defined\n     * @param {number} x\n     * @param {number} y\n     */\n    function elementPrototypeScrollFallback(x, y) {\n        this.__adjustingScrollPosition = true;\n        this.scrollLeft = x;\n        this.scrollTop = y;\n        delete this.__adjustingScrollPosition;\n    }\n    /**\n     * A fallback if Element.prototype.scrollTo is not defined\n     * @param {number} x\n     * @param {number} y\n     */\n    function elementPrototypeScrollToFallback(x, y) {\n        return elementPrototypeScrollFallback.call(this, x, y);\n    }\n    /**\n     * A fallback if Element.prototype.scrollBy is not defined\n     * @param {number} x\n     * @param {number} y\n     */\n    function elementPrototypeScrollByFallback(x, y) {\n        this.__adjustingScrollPosition = true;\n        this.scrollLeft += x;\n        this.scrollTop += y;\n        delete this.__adjustingScrollPosition;\n    }\n    /**\n     * Gets the original non-patched prototype method for the given kind\n     * @param {ScrollMethodName} kind\n     * @param {Element|Window} element\n     * @return {Function}\n     */\n    function getOriginalScrollMethodForKind(kind, element) {\n        switch (kind) {\n            case \"scroll\":\n                if (element instanceof Element) {\n                    if (ELEMENT_ORIGINAL_SCROLL != null) {\n                        return ELEMENT_ORIGINAL_SCROLL;\n                    }\n                    else {\n                        return elementPrototypeScrollFallback;\n                    }\n                }\n                else {\n                    return WINDOW_ORIGINAL_SCROLL;\n                }\n            case \"scrollBy\":\n                if (element instanceof Element) {\n                    if (ELEMENT_ORIGINAL_SCROLL_BY != null) {\n                        return ELEMENT_ORIGINAL_SCROLL_BY;\n                    }\n                    else {\n                        return elementPrototypeScrollByFallback;\n                    }\n                }\n                else {\n                    return WINDOW_ORIGINAL_SCROLL_BY;\n                }\n            case \"scrollTo\":\n                if (element instanceof Element) {\n                    if (ELEMENT_ORIGINAL_SCROLL_TO != null) {\n                        return ELEMENT_ORIGINAL_SCROLL_TO;\n                    }\n                    else {\n                        return elementPrototypeScrollToFallback;\n                    }\n                }\n                else {\n                    return WINDOW_ORIGINAL_SCROLL_TO;\n                }\n        }\n    }\n\n    /**\n     * Gets the Smooth Scroll Options to use for the step function\n     * @param {Element|Window} element\n     * @param {number} x\n     * @param {number} y\n     * @param {ScrollMethodName} kind\n     * @returns {ISmoothScrollOptions}\n     */\n    function getSmoothScrollOptions(element, x, y, kind) {\n        var startTime = now();\n        if (!(element instanceof Element)) {\n            // Use window as the scroll container\n            var scrollX_1 = window.scrollX, pageXOffset_1 = window.pageXOffset, scrollY_1 = window.scrollY, pageYOffset_1 = window.pageYOffset;\n            var startX = scrollX_1 == null || scrollX_1 === 0 ? pageXOffset_1 : scrollX_1;\n            var startY = scrollY_1 == null || scrollY_1 === 0 ? pageYOffset_1 : scrollY_1;\n            return {\n                startTime: startTime,\n                startX: startX,\n                startY: startY,\n                endX: Math.floor(kind === \"scrollBy\" ? startX + x : x),\n                endY: Math.floor(kind === \"scrollBy\" ? startY + y : y),\n                method: getOriginalScrollMethodForKind(\"scrollTo\", window).bind(window),\n                scroller: getScrollingElement()\n            };\n        }\n        else {\n            var scrollLeft = element.scrollLeft, scrollTop = element.scrollTop;\n            var startX = scrollLeft;\n            var startY = scrollTop;\n            return {\n                startTime: startTime,\n                startX: startX,\n                startY: startY,\n                endX: Math.floor(kind === \"scrollBy\" ? startX + x : x),\n                endY: Math.floor(kind === \"scrollBy\" ? startY + y : y),\n                method: getOriginalScrollMethodForKind(\"scrollTo\", element).bind(element),\n                scroller: element\n            };\n        }\n    }\n\n    /**\n     * Ensures that the given value is numeric\n     * @param {number} value\n     * @return {number}\n     */\n    function ensureNumeric(value) {\n        if (value == null)\n            return 0;\n        else if (typeof value === \"number\") {\n            return value;\n        }\n        else if (typeof value === \"string\") {\n            return parseFloat(value);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Returns true if the given value is some ScrollToOptions\n     * @param {number | ScrollToOptions} value\n     * @return {value is ScrollToOptions}\n     */\n    function isScrollToOptions(value) {\n        return value != null && typeof value === \"object\";\n    }\n\n    /**\n     * Handles a scroll method\n     * @param {Element|Window} element\n     * @param {ScrollMethodName} kind\n     * @param {number | ScrollToOptions} optionsOrX\n     * @param {number} y\n     */\n    function handleScrollMethod(element, kind, optionsOrX, y) {\n        onScrollWithOptions(getScrollToOptionsWithValidation(optionsOrX, y), element, kind);\n    }\n    /**\n     * Invoked when a 'ScrollToOptions' dict is provided to 'scroll()' as the first argument\n     * @param {ScrollToOptions} options\n     * @param {Element|Window} element\n     * @param {ScrollMethodName} kind\n     */\n    function onScrollWithOptions(options, element, kind) {\n        var behavior = getScrollBehavior(element, options);\n        // If the behavior is 'auto' apply instantaneous scrolling\n        if (behavior == null || behavior === \"auto\") {\n            getOriginalScrollMethodForKind(kind, element).call(element, options.left, options.top);\n        }\n        else {\n            smoothScroll(getSmoothScrollOptions(element, options.left, options.top, kind));\n        }\n    }\n    /**\n     * Normalizes the given scroll coordinates\n     * @param {number?} x\n     * @param {number?} y\n     * @return {Required<Pick<ScrollToOptions, \"top\" | \"left\">>}\n     */\n    function normalizeScrollCoordinates(x, y) {\n        return {\n            left: ensureNumeric(x),\n            top: ensureNumeric(y)\n        };\n    }\n    /**\n     * Gets ScrollToOptions based on the given arguments. Will throw if validation fails\n     * @param {number | ScrollToOptions} optionsOrX\n     * @param {number} y\n     * @return {Required<ScrollToOptions>}\n     */\n    function getScrollToOptionsWithValidation(optionsOrX, y) {\n        // If only one argument is given, and it isn't an options object, throw a TypeError\n        if (y === undefined && !isScrollToOptions(optionsOrX)) {\n            throw new TypeError(\"Failed to execute 'scroll' on 'Element': parameter 1 ('options') is not an object.\");\n        }\n        // Scroll based on the primitive values given as arguments\n        if (!isScrollToOptions(optionsOrX)) {\n            return __assign(__assign({}, normalizeScrollCoordinates(optionsOrX, y)), { behavior: \"auto\" });\n        }\n        // Scroll based on the received options object\n        else {\n            return __assign(__assign({}, normalizeScrollCoordinates(optionsOrX.left, optionsOrX.top)), { behavior: optionsOrX.behavior == null ? \"auto\" : optionsOrX.behavior });\n        }\n    }\n\n    /**\n     * Patches the 'scroll' method on the Element prototype\n     */\n    function patchElementScroll() {\n        Element.prototype.scroll = function (optionsOrX, y) {\n            handleScrollMethod(this, \"scroll\", optionsOrX, y);\n        };\n    }\n\n    /**\n     * Patches the 'scrollBy' method on the Element prototype\n     */\n    function patchElementScrollBy() {\n        Element.prototype.scrollBy = function (optionsOrX, y) {\n            handleScrollMethod(this, \"scrollBy\", optionsOrX, y);\n        };\n    }\n\n    /**\n     * Patches the 'scrollTo' method on the Element prototype\n     */\n    function patchElementScrollTo() {\n        Element.prototype.scrollTo = function (optionsOrX, y) {\n            handleScrollMethod(this, \"scrollTo\", optionsOrX, y);\n        };\n    }\n\n    /**\n     * Patches the 'scroll' method on the Window prototype\n     */\n    function patchWindowScroll() {\n        window.scroll = function (optionsOrX, y) {\n            handleScrollMethod(this, \"scroll\", optionsOrX, y);\n        };\n    }\n\n    /**\n     * Patches the 'scrollBy' method on the Window prototype\n     */\n    function patchWindowScrollBy() {\n        window.scrollBy = function (optionsOrX, y) {\n            handleScrollMethod(this, \"scrollBy\", optionsOrX, y);\n        };\n    }\n\n    /**\n     * Patches the 'scrollTo' method on the Window prototype\n     */\n    function patchWindowScrollTo() {\n        window.scrollTo = function (optionsOrX, y) {\n            handleScrollMethod(this, \"scrollTo\", optionsOrX, y);\n        };\n    }\n\n    // tslint:disable:no-any\n    /**\n     * Gets the parent of an element, taking into account DocumentFragments, ShadowRoots, as well as the root context (window)\n     * @param {EventTarget} currentElement\n     * @returns {EventTarget | null}\n     */\n    function getParent(currentElement) {\n        if (\"nodeType\" in currentElement && currentElement.nodeType === 1) {\n            return currentElement.parentNode;\n        }\n        if (\"ShadowRoot\" in window && currentElement instanceof window.ShadowRoot) {\n            return currentElement.host;\n        }\n        else if (currentElement === document) {\n            return window;\n        }\n        else if (currentElement instanceof Node)\n            return currentElement.parentNode;\n        return null;\n    }\n\n    /**\n     * Returns true if the given overflow property represents a scrollable overflow value\n     * @param {string | null} overflow\n     * @return {boolean}\n     */\n    function canOverflow(overflow) {\n        return overflow !== \"visible\" && overflow !== \"clip\";\n    }\n    /**\n     * Returns true if the given element is scrollable\n     * @param {Element} element\n     * @return {boolean}\n     */\n    function isScrollable(element) {\n        if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n            var style = getComputedStyle(element, null);\n            return canOverflow(style.overflowY) || canOverflow(style.overflowX);\n        }\n        return false;\n    }\n    /**\n     * Finds the nearest ancestor of an element that can scroll\n     * @param {Element} target\n     * @returns {Element|Window?}\n     */\n    function findNearestAncestorsWithScrollBehavior(target) {\n        var currentElement = target;\n        var scrollingElement = getScrollingElement();\n        while (currentElement != null) {\n            var behavior = getScrollBehavior(currentElement);\n            if (behavior != null && (currentElement === scrollingElement || isScrollable(currentElement))) {\n                return [currentElement, behavior];\n            }\n            var parent_1 = getParent(currentElement);\n            currentElement = parent_1;\n        }\n        // No such element could be found. Start over, but this time find the nearest ancestor that can simply scroll\n        currentElement = target;\n        while (currentElement != null) {\n            if (currentElement === scrollingElement || isScrollable(currentElement)) {\n                return [currentElement, \"auto\"];\n            }\n            var parent_2 = getParent(currentElement);\n            currentElement = parent_2;\n        }\n        // Default to the scrolling element\n        return [scrollingElement, \"auto\"];\n    }\n\n    // tslint:disable:no-any\n    /**\n     * Finds the nearest root from an element\n     * @param {Element} target\n     * @returns {Document|ShadowRoot}\n     */\n    function findNearestRoot(target) {\n        var currentElement = target;\n        while (currentElement != null) {\n            if (\"ShadowRoot\" in window && currentElement instanceof window.ShadowRoot) {\n                // Assume this is a ShadowRoot\n                return currentElement;\n            }\n            var parent_1 = getParent(currentElement);\n            if (parent_1 === currentElement) {\n                return document;\n            }\n            currentElement = parent_1;\n        }\n        return document;\n    }\n\n    /**\n     * Gets the origin of the given Location or HTMLAnchorElement if available in the runtime, and otherwise shims it. (it's a one-liner)\n     * @returns {string}\n     */\n    function getLocationOrigin(locationLike) {\n        if (locationLike === void 0) { locationLike = location; }\n        if (\"origin\" in locationLike && locationLike.origin != null) {\n            return locationLike.origin;\n        }\n        var port = locationLike.port != null && locationLike.port.length > 0 ? \":\" + locationLike.port : \"\";\n        if (locationLike.protocol === \"http:\" && port === \":80\") {\n            port = \"\";\n        }\n        else if (locationLike.protocol === \"https:\" && port === \":443\") {\n            port = \"\";\n        }\n        return locationLike.protocol + \"//\" + locationLike.hostname + port;\n    }\n\n    /**\n     * A Regular expression that matches id's of the form \"#[digit]\"\n     * @type {RegExp}\n     */\n    var ID_WITH_LEADING_DIGIT_REGEXP = /^#\\d/;\n    /**\n     * Catches anchor navigation to IDs within the same root and ensures that they can be smooth-scrolled\n     * if the scroll behavior is smooth in the first rooter within that context\n     */\n    function catchNavigation() {\n        // Listen for 'click' events globally\n        window.addEventListener(\"click\", function (e) {\n            // Only work with trusted events on HTMLAnchorElements\n            if (!e.isTrusted || !(e.target instanceof HTMLAnchorElement))\n                return;\n            var _a = e.target, pathname = _a.pathname, search = _a.search, hash = _a.hash;\n            var pointsToCurrentPage = getLocationOrigin(e.target) === getLocationOrigin(location) && pathname === location.pathname && search === location.search;\n            // Only work with HTMLAnchorElements that navigates to a specific ID on the current page\n            if (!pointsToCurrentPage || hash == null || hash.length < 1) {\n                return;\n            }\n            // Find the nearest root, whether it be a ShadowRoot or the document itself\n            var root = findNearestRoot(e.target);\n            // Attempt to match the selector from that root. querySelector' doesn't support IDs that start with a digit, so work around that limitation\n            var elementMatch = hash.match(ID_WITH_LEADING_DIGIT_REGEXP) != null ? root.getElementById(hash.slice(1)) : root.querySelector(hash);\n            // If no selector could be found, don't proceed\n            if (elementMatch == null)\n                return;\n            // Find the nearest ancestor that can be scrolled\n            var _b = __read(findNearestAncestorsWithScrollBehavior(elementMatch), 2), behavior = _b[1];\n            // If the behavior isn't smooth, don't proceed\n            if (behavior !== \"smooth\")\n                return;\n            // Otherwise, first prevent the default action.\n            e.preventDefault();\n            // Now, scroll to the element with that ID\n            elementMatch.scrollIntoView({\n                behavior: behavior\n            });\n        });\n    }\n\n    var ELEMENT_ORIGINAL_SCROLL_INTO_VIEW = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollIntoView;\n\n    /**\n     * The majority of this file is based on https://github.com/stipsan/compute-scroll-into-view (MIT license),\n     * but has been rewritten to accept a scroller as an argument.\n     */\n    /**\n     * Find out which edge to align against when logical scroll position is \"nearest\"\n     * Interesting fact: \"nearest\" works similarly to \"if-needed\", if the element is fully visible it will not scroll it\n     *\n     * Legends:\n     * ┌────────┐ ┏ ━ ━ ━ ┓\n     * │ target │   frame\n     * └────────┘ ┗ ━ ━ ━ ┛\n     */\n    function alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {\n        /**\n         * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n         *\n         *          ┌──┐\n         *        ┏━│━━│━┓\n         *          │  │\n         *        ┃ │  │ ┃        do nothing\n         *          │  │\n         *        ┗━│━━│━┛\n         *          └──┘\n         *\n         *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n         *\n         *    ┏ ━ ━ ━ ━ ┓\n         *   ┌───────────┐\n         *   │┃         ┃│        do nothing\n         *   └───────────┘\n         *    ┗ ━ ━ ━ ━ ┛\n         */\n        if ((elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||\n            (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)) {\n            return 0;\n        }\n        /**\n         * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n         *\n         *          ┌──┐\n         *        ┏━│━━│━┓         ┏━┌━━┐━┓\n         *          └──┘             │  │\n         *  from  ┃      ┃     to  ┃ └──┘ ┃\n         *\n         *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n         *\n         * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n         *\n         *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n         *                           │  │\n         *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n         *          │  │             │  │\n         *        ┗━│━━│━┛         ┗━│━━│━┛\n         *          │  │             └──┘\n         *          │  │\n         *          └──┘\n         *\n         * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n         *\n         *       from                 to\n         *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n         *  ┌───┐                 ┌───┐\n         *  │ ┃ │       ┃         ┃   │     ┃\n         *  └───┘                 └───┘\n         *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n         *\n         * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n         *\n         *       from                 to\n         *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n         *        ┌───────────┐   ┌───────────┐\n         *    ┃   │     ┃     │   ┃         ┃ │\n         *        └───────────┘   └───────────┘\n         *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n         */\n        if ((elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n            (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)) {\n            return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;\n        }\n        /**\n         * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n         *\n         *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n         *\n         *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n         *          ┌──┐             │  │\n         *        ┗━│━━│━┛         ┗━└━━┘━┛\n         *          └──┘\n         *\n         * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n         *\n         *          ┌──┐\n         *          │  │\n         *          │  │             ┌──┐\n         *        ┏━│━━│━┓         ┏━│━━│━┓\n         *          │  │             │  │\n         *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n         *                           │  │\n         *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n         *\n         * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n         *\n         *           from                 to\n         *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n         *  ┌───────────┐           ┌───────────┐\n         *  │     ┃     │   ┃       │ ┃         ┃\n         *  └───────────┘           └───────────┘\n         *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n         *\n         * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n         *\n         *           from                 to\n         *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n         *                ┌───┐             ┌───┐\n         *        ┃       │ ┃ │       ┃     │   ┃\n         *                └───┘             └───┘\n         *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n         *\n         */\n        if ((elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) || (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)) {\n            return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;\n        }\n        return 0;\n    }\n    function computeScrollIntoView(target, scroller, options) {\n        var block = options.block, inline = options.inline;\n        // Used to handle the top most element that can be scrolled\n        var scrollingElement = getScrollingElement();\n        // Support pinch-zooming properly, making sure elements scroll into the visual viewport\n        // Browsers that don't support visualViewport will report the layout viewport dimensions on document.documentElement.clientWidth/Height\n        // and viewport dimensions on window.innerWidth/Height\n        // https://www.quirksmode.org/mobile/viewports2.html\n        // https://bokand.github.io/viewport/index.html\n        var viewportWidth = window.visualViewport != null ? visualViewport.width : innerWidth;\n        var viewportHeight = window.visualViewport != null ? visualViewport.height : innerHeight;\n        var viewportX = window.scrollX != null ? window.scrollX : window.pageXOffset;\n        var viewportY = window.scrollY != null ? window.scrollY : window.pageYOffset;\n        var _a = target.getBoundingClientRect(), targetHeight = _a.height, targetWidth = _a.width, targetTop = _a.top, targetRight = _a.right, targetBottom = _a.bottom, targetLeft = _a.left;\n        // These values mutate as we loop through and generate scroll coordinates\n        var targetBlock = block === \"start\" || block === \"nearest\" ? targetTop : block === \"end\" ? targetBottom : targetTop + targetHeight / 2; // block === 'center\n        var targetInline = inline === \"center\" ? targetLeft + targetWidth / 2 : inline === \"end\" ? targetRight : targetLeft; // inline === 'start || inline === 'nearest\n        var _b = scroller.getBoundingClientRect(), height = _b.height, width = _b.width, top = _b.top, right = _b.right, bottom = _b.bottom, left = _b.left;\n        var frameStyle = getComputedStyle(scroller);\n        var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);\n        var borderTop = parseInt(frameStyle.borderTopWidth, 10);\n        var borderRight = parseInt(frameStyle.borderRightWidth, 10);\n        var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);\n        var blockScroll = 0;\n        var inlineScroll = 0;\n        // The property existance checks for offset[Width|Height] is because only HTMLElement objects have them, but any Element might pass by here\n        // @TODO find out if the \"as HTMLElement\" overrides can be dropped\n        var scrollbarWidth = \"offsetWidth\" in scroller ? scroller.offsetWidth - scroller.clientWidth - borderLeft - borderRight : 0;\n        var scrollbarHeight = \"offsetHeight\" in scroller ? scroller.offsetHeight - scroller.clientHeight - borderTop - borderBottom : 0;\n        if (scrollingElement === scroller) {\n            // Handle viewport logic (document.documentElement or document.body)\n            if (block === \"start\") {\n                blockScroll = targetBlock;\n            }\n            else if (block === \"end\") {\n                blockScroll = targetBlock - viewportHeight;\n            }\n            else if (block === \"nearest\") {\n                blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);\n            }\n            else {\n                // block === 'center' is the default\n                blockScroll = targetBlock - viewportHeight / 2;\n            }\n            if (inline === \"start\") {\n                inlineScroll = targetInline;\n            }\n            else if (inline === \"center\") {\n                inlineScroll = targetInline - viewportWidth / 2;\n            }\n            else if (inline === \"end\") {\n                inlineScroll = targetInline - viewportWidth;\n            }\n            else {\n                // inline === 'nearest' is the default\n                inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);\n            }\n            // Apply scroll position offsets and ensure they are within bounds\n            // @TODO add more test cases to cover this 100%\n            blockScroll = Math.max(0, blockScroll + viewportY);\n            inlineScroll = Math.max(0, inlineScroll + viewportX);\n        }\n        else {\n            // Handle each scrolling frame that might exist between the target and the viewport\n            if (block === \"start\") {\n                blockScroll = targetBlock - top - borderTop;\n            }\n            else if (block === \"end\") {\n                blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;\n            }\n            else if (block === \"nearest\") {\n                blockScroll = alignNearest(top, bottom, height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);\n            }\n            else {\n                // block === 'center' is the default\n                blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2;\n            }\n            if (inline === \"start\") {\n                inlineScroll = targetInline - left - borderLeft;\n            }\n            else if (inline === \"center\") {\n                inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2;\n            }\n            else if (inline === \"end\") {\n                inlineScroll = targetInline - right + borderRight + scrollbarWidth;\n            }\n            else {\n                // inline === 'nearest' is the default\n                inlineScroll = alignNearest(left, right, width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);\n            }\n            var scrollLeft = scroller.scrollLeft, scrollTop = scroller.scrollTop;\n            // Ensure scroll coordinates are not out of bounds while applying scroll offsets\n            blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, scroller.scrollHeight - height + scrollbarHeight));\n            inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, scroller.scrollWidth - width + scrollbarWidth));\n        }\n        return {\n            top: blockScroll,\n            left: inlineScroll\n        };\n    }\n\n    /**\n     * Patches the 'scrollIntoView' method on the Element prototype\n     */\n    function patchElementScrollIntoView() {\n        Element.prototype.scrollIntoView = function (arg) {\n            var normalizedOptions = arg == null || arg === true\n                ? {\n                    block: \"start\",\n                    inline: \"nearest\"\n                }\n                : arg === false\n                    ? {\n                        block: \"end\",\n                        inline: \"nearest\"\n                    }\n                    : arg;\n            // Find the nearest ancestor that can be scrolled\n            var _a = __read(findNearestAncestorsWithScrollBehavior(this), 2), ancestorWithScroll = _a[0], ancestorWithScrollBehavior = _a[1];\n            var behavior = normalizedOptions.behavior != null ? normalizedOptions.behavior : ancestorWithScrollBehavior;\n            // If the behavior isn't smooth, simply invoke the original implementation and do no more\n            if (behavior !== \"smooth\") {\n                // Assert that 'scrollIntoView' is actually defined\n                if (ELEMENT_ORIGINAL_SCROLL_INTO_VIEW != null) {\n                    ELEMENT_ORIGINAL_SCROLL_INTO_VIEW.call(this, normalizedOptions);\n                }\n                // Otherwise, invoke 'scrollTo' instead and provide the scroll coordinates\n                else {\n                    var _b = computeScrollIntoView(this, ancestorWithScroll, normalizedOptions), top_1 = _b.top, left = _b.left;\n                    getOriginalScrollMethodForKind(\"scrollTo\", this).call(this, left, top_1);\n                }\n                return;\n            }\n            ancestorWithScroll.scrollTo(__assign({ behavior: behavior }, computeScrollIntoView(this, ancestorWithScroll, normalizedOptions)));\n        };\n        // On IE11, HTMLElement has its own declaration of scrollIntoView and does not inherit this from the prototype chain, so we'll need to patch that one too.\n        if (HTMLElement.prototype.scrollIntoView != null && HTMLElement.prototype.scrollIntoView !== Element.prototype.scrollIntoView) {\n            HTMLElement.prototype.scrollIntoView = Element.prototype.scrollIntoView;\n        }\n    }\n\n    var ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR = UNSUPPORTED_ENVIRONMENT\n        ? undefined\n        : Object.getOwnPropertyDescriptor(Element.prototype, \"scrollTop\").set;\n\n    /**\n     * Patches the 'scrollTop' property descriptor on the Element prototype\n     */\n    function patchElementScrollTop() {\n        Object.defineProperty(Element.prototype, \"scrollTop\", {\n            set: function (scrollTop) {\n                if (this.__adjustingScrollPosition) {\n                    return ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR.call(this, scrollTop);\n                }\n                handleScrollMethod(this, \"scrollTo\", this.scrollLeft, scrollTop);\n                return scrollTop;\n            }\n        });\n    }\n\n    var ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR = UNSUPPORTED_ENVIRONMENT\n        ? undefined\n        : Object.getOwnPropertyDescriptor(Element.prototype, \"scrollLeft\").set;\n\n    /**\n     * Patches the 'scrollLeft' property descriptor on the Element prototype\n     */\n    function patchElementScrollLeft() {\n        Object.defineProperty(Element.prototype, \"scrollLeft\", {\n            set: function (scrollLeft) {\n                if (this.__adjustingScrollPosition) {\n                    return ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR.call(this, scrollLeft);\n                }\n                handleScrollMethod(this, \"scrollTo\", scrollLeft, this.scrollTop);\n                return scrollLeft;\n            }\n        });\n    }\n\n    /**\n     * Applies the polyfill\n     */\n    function patch() {\n        // Element.prototype methods\n        patchElementScroll();\n        patchElementScrollBy();\n        patchElementScrollTo();\n        patchElementScrollIntoView();\n        // Element.prototype descriptors\n        patchElementScrollLeft();\n        patchElementScrollTop();\n        // window methods\n        patchWindowScroll();\n        patchWindowScrollBy();\n        patchWindowScrollTo();\n        // Navigation\n        catchNavigation();\n    }\n\n    /**\n     * Is true if the browser natively supports the Element.prototype.[scroll|scrollTo|scrollBy|scrollIntoView] methods\n     * @type {boolean}\n     */\n    var SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS = UNSUPPORTED_ENVIRONMENT\n        ? false\n        : \"scroll\" in Element.prototype && \"scrollTo\" in Element.prototype && \"scrollBy\" in Element.prototype && \"scrollIntoView\" in Element.prototype;\n\n    if (!UNSUPPORTED_ENVIRONMENT && (!SUPPORTS_SCROLL_BEHAVIOR || !SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS)) {\n        patch();\n    }\n\n}());\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Njcm9sbC1iZWhhdmlvci1wb2x5ZmlsbC9kaXN0L2luZGV4LmpzPzYzMTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixNQUFNLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSx3Q0FBd0M7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQyxlQUFlLGNBQWM7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGVBQWU7QUFDOUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsaUJBQWlCO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSx5QkFBeUI7QUFDeEMsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsZUFBZTtBQUM5QixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrQ0FBK0MsbUJBQW1CO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpRUFBaUUsdUVBQXVFO0FBQy9LO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esc0NBQXNDLHlCQUF5QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0lBQStJO0FBQy9JLDRIQUE0SDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Njcm9sbC1iZWhhdmlvci1wb2x5ZmlsbC9kaXN0L2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgVU5TVVBQT1JURURfRU5WSVJPTk1FTlQgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiO1xuXG4gICAgLyoqXG4gICAgICogSXMgdHJ1ZSBpZiB0aGUgYnJvd3NlciBuYXRpdmVseSBzdXBwb3J0cyB0aGUgJ3Njcm9sbC1iZWhhdmlvcicgQ1NTLXByb3BlcnR5LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHZhciBTVVBQT1JUU19TQ1JPTExfQkVIQVZJT1IgPSBVTlNVUFBPUlRFRF9FTlZJUk9OTUVOVCA/IGZhbHNlIDogXCJzY3JvbGxCZWhhdmlvclwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcblxuICAgIFxuXG4gICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG4gICAgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuICAgIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gICAgVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gICAgS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG4gICAgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuICAgIE1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG4gICAgU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbiAgICBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuICAgIHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICAgICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgICAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2Nyb2xsaW5nRWxlbWVudCgpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFNUWUxFX0FUVFJJQlVURV9QUk9QRVJUWV9OQU1FID0gXCJzY3JvbGwtYmVoYXZpb3JcIjtcbiAgICB2YXIgU1RZTEVfQVRUUklCVVRFX1BST1BFUlRZX1JFR0VYUCA9IG5ldyBSZWdFeHAoU1RZTEVfQVRUUklCVVRFX1BST1BFUlRZX05BTUUgKyBcIjpcXFxccyooW147XSopXCIpO1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIEVsZW1lbnQsIHRoaXMgZnVuY3Rpb24gYXBwZW5kcyB0aGUgZ2l2ZW4gU2Nyb2xsQmVoYXZpb3IgQ1NTIHByb3BlcnR5IHZhbHVlIHRvIHRoZSBlbGVtZW50cycgJ3N0eWxlJyBhdHRyaWJ1dGUuXG4gICAgICogSWYgaXQgZG9lc250IGFscmVhZHkgaGF2ZSBvbmUsIGl0IHdpbGwgYWRkIGl0LlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7U2Nyb2xsQmVoYXZpb3J9IGJlaGF2aW9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXBwZW5kU2Nyb2xsQmVoYXZpb3JUb1N0eWxlQXR0cmlidXRlKGVsZW1lbnQsIGJlaGF2aW9yKSB7XG4gICAgICAgIHZhciBhZGRpdGlvbiA9IFNUWUxFX0FUVFJJQlVURV9QUk9QRVJUWV9OQU1FICsgXCI6XCIgKyBiZWhhdmlvcjtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZVZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZVZhbHVlID09IG51bGwgfHwgYXR0cmlidXRlVmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYWRkaXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBzdHlsZSBhdHRyaWJ1dGUgbWF5IGFscmVhZHkgaW5jbHVkZSBhICdzY3JvbGwtYmVoYXZpb3I6PHNvbWV0aGluZz4nIGluIHdoaWNoIGNhc2UgdGhhdCBzaG91bGQgYmUgcmVwbGFjZWRcbiAgICAgICAgdmFyIGV4aXN0aW5nVmFsdWVGb3JQcm9wZXJ0eSA9IHBhcnNlU2Nyb2xsQmVoYXZpb3JGcm9tU3R5bGVBdHRyaWJ1dGUoZWxlbWVudCk7XG4gICAgICAgIGlmIChleGlzdGluZ1ZhbHVlRm9yUHJvcGVydHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50UHJvcGVydHkgPSBTVFlMRV9BVFRSSUJVVEVfUFJPUEVSVFlfTkFNRSArIFwiOlwiICsgZXhpc3RpbmdWYWx1ZUZvclByb3BlcnR5O1xuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgdmFyaWFudCB0aGF0IGVuZHMgd2l0aCBhIHNlbWktY29sb24gd2hpY2ggaXQgbWF5XG4gICAgICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9IGF0dHJpYnV0ZVZhbHVlLnJlcGxhY2UocmVwbGFjZW1lbnRQcm9wZXJ0eSArIFwiO1wiLCBcIlwiKTtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIHZhcmlhbnQgdGhhdCAqZG9lc24ndCogZW5kIHdpdGggYSBzZW1pLWNvbG9uXG4gICAgICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9IGF0dHJpYnV0ZVZhbHVlLnJlcGxhY2UocmVwbGFjZW1lbnRQcm9wZXJ0eSwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93LCBhcHBlbmQgdGhlIGJlaGF2aW9yIHRvIHRoZSBzdHJpbmcuXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYXR0cmlidXRlVmFsdWUuZW5kc1dpdGgoXCI7XCIpID8gXCJcIiArIGF0dHJpYnV0ZVZhbHVlICsgYWRkaXRpb24gOiBcIjtcIiArIGF0dHJpYnV0ZVZhbHVlICsgYWRkaXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBFbGVtZW50LCB0aGlzIGZ1bmN0aW9uIGF0dGVtcHRzIHRvIHBhcnNlIGl0cyAnc3R5bGUnIGF0dHJpYnV0ZSAoaWYgaXQgaGFzIG9uZSknIHRvIGV4dHJhY3RcbiAgICAgKiBhIHZhbHVlIGZvciB0aGUgJ3Njcm9sbC1iZWhhdmlvcicgQ1NTIHByb3BlcnR5IChpZiBpdCBpcyBnaXZlbiB3aXRoaW4gdGhhdCBzdHlsZSBhdHRyaWJ1dGUpXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHJldHVybnMge1Njcm9sbEJlaGF2aW9yP31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVNjcm9sbEJlaGF2aW9yRnJvbVN0eWxlQXR0cmlidXRlKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHN0eWxlQXR0cmlidXRlVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgICAgICBpZiAoc3R5bGVBdHRyaWJ1dGVWYWx1ZSAhPSBudWxsICYmIHN0eWxlQXR0cmlidXRlVmFsdWUuaW5jbHVkZXMoU1RZTEVfQVRUUklCVVRFX1BST1BFUlRZX05BTUUpKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBzdHlsZUF0dHJpYnV0ZVZhbHVlLm1hdGNoKFNUWUxFX0FUVFJJQlVURV9QUk9QRVJUWV9SRUdFWFApO1xuICAgICAgICAgICAgaWYgKG1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQobWF0Y2gsIDIpLCBiZWhhdmlvciA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIGlmIChiZWhhdmlvciAhPSBudWxsICYmIGJlaGF2aW9yICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZWhhdmlvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVEZWNsYXJhdGlvblByb3BlcnR5TmFtZSA9IFwic2Nyb2xsQmVoYXZpb3JcIjtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSBzY3JvbGwgYmVoYXZpb3IgdG8gdXNlLCBkZXBlbmRpbmcgb24gdGhlIGdpdmVuIFNjcm9sbE9wdGlvbnMgYW5kIHRoZSBwb3NpdGlvbiBvZiB0aGUgRWxlbWVudFxuICAgICAqIHdpdGhpbiB0aGUgRE9NXG4gICAgICogQHBhcmFtIHtFbGVtZW50fEhUTUxFbGVtZW50fFdpbmRvd30gaW5wdXRUYXJnZXRcbiAgICAgKiBAcGFyYW0ge1Njcm9sbE9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm5zIHtTY3JvbGxCZWhhdmlvcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTY3JvbGxCZWhhdmlvcihpbnB1dFRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICAvLyBJZiB0aGUgZ2l2ZW4gJ2JlaGF2aW9yJyBpcyAnc21vb3RoJywgYXBwbHkgc21vb3RoIHNjcm9sbGluZyBubyBtYXR0ZXIgd2hhdFxuICAgICAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuYmVoYXZpb3IgPT09IFwic21vb3RoXCIpXG4gICAgICAgICAgICByZXR1cm4gXCJzbW9vdGhcIjtcbiAgICAgICAgdmFyIHRhcmdldCA9IFwic3R5bGVcIiBpbiBpbnB1dFRhcmdldCA/IGlucHV0VGFyZ2V0IDogZ2V0U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIGlmIChcInN0eWxlXCIgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBzY3JvbGwtYmVoYXZpb3IgaXMgc2V0IGFzIGEgcHJvcGVydHkgb24gdGhlIENTU1N0eWxlRGVjbGFyYXRpb25cbiAgICAgICAgICAgIHZhciBzY3JvbGxCZWhhdmlvclByb3BlcnR5VmFsdWUgPSB0YXJnZXQuc3R5bGVbc3R5bGVEZWNsYXJhdGlvblByb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAvLyBSZXR1cm4gaXQgaWYgaXQgaXMgZ2l2ZW4gYW5kIGhhcyBhIHByb3BlciB2YWx1ZVxuICAgICAgICAgICAgaWYgKHNjcm9sbEJlaGF2aW9yUHJvcGVydHlWYWx1ZSAhPSBudWxsICYmIHNjcm9sbEJlaGF2aW9yUHJvcGVydHlWYWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gc2Nyb2xsQmVoYXZpb3JQcm9wZXJ0eVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlVmFsdWUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwic2Nyb2xsLWJlaGF2aW9yXCIpO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZVZhbHVlICE9IG51bGwgJiYgYXR0cmlidXRlVmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGF0dHJpYnV0ZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGNoZWNrIGlmIGl0IGlzIHNldCBhcyBhbiBpbmxpbmUgc3R5bGVcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VTY3JvbGxCZWhhdmlvckZyb21TdHlsZUF0dHJpYnV0ZSh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUYWtlIHRoZSBjb21wdXRlZCBzdHlsZSBmb3IgdGhlIGVsZW1lbnQgYW5kIHNlZSBpZiBpdCBjb250YWlucyBhIHNwZWNpZmljICdzY3JvbGwtYmVoYXZpb3InIHZhbHVlXG4gICAgICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciBjb21wdXRlZFN0eWxlVmFsdWUgPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJzY3JvbGxCZWhhdmlvclwiKTtcbiAgICAgICAgICAgIGlmIChjb21wdXRlZFN0eWxlVmFsdWUgIT0gbnVsbCAmJiBjb21wdXRlZFN0eWxlVmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkU3R5bGVWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBhbGwgb3RoZXIgY2FzZXMsIHVzZSB0aGUgdmFsdWUgZnJvbSB0aGUgQ1NTT01cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIFxuXG4gICAgXG5cbiAgICB2YXIgSEFMRiA9IDAuNTtcbiAgICAvKipcbiAgICAgKiBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuIGFwcGx5aW5nIHRoZSBzbW9vdGggc2Nyb2xsaW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVhc2Uoaykge1xuICAgICAgICByZXR1cm4gSEFMRiAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbiAgICB9XG5cbiAgICB2YXIgTk9PUCA9IHtcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHsgfVxuICAgIH07XG4gICAgdmFyIG1hcCA9IHR5cGVvZiBXZWFrTWFwID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkIDogbmV3IFdlYWtNYXAoKTtcbiAgICBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsU25hcChzY3JvbGxlcikge1xuICAgICAgICAvLyBJZiBzY3JvbGwtYmVoYXZpb3IgaXMgbmF0aXZlbHkgc3VwcG9ydGVkLCBvciBpZiB0aGVyZSBpcyBubyBuYXRpdmUgV2Vha01hcCBzdXBwb3J0LCB0aGVyZSdzIG5vIG5lZWQgZm9yIHRoaXMgZml4XG4gICAgICAgIGlmIChTVVBQT1JUU19TQ1JPTExfQkVIQVZJT1IgfHwgbWFwID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOT09QO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZ2V0U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICB2YXIgY2FjaGVkU2Nyb2xsU25hcFZhbHVlO1xuICAgICAgICB2YXIgY2FjaGVkU2Nyb2xsQmVoYXZpb3JTdHlsZUF0dHJpYnV0ZVZhbHVlO1xuICAgICAgICB2YXIgc2Vjb25kYXJ5U2Nyb2xsZXI7XG4gICAgICAgIHZhciBzZWNvbmRhcnlTY3JvbGxlckNhY2hlZFNjcm9sbFNuYXBWYWx1ZTtcbiAgICAgICAgdmFyIHNlY29uZGFyeVNjcm9sbGVyQ2FjaGVkU2Nyb2xsQmVoYXZpb3JTdHlsZUF0dHJpYnV0ZVZhbHVlO1xuICAgICAgICB2YXIgZXhpc3RpbmdSZXN1bHQgPSBtYXAuZ2V0KHNjcm9sbGVyKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNhY2hlZFNjcm9sbFNuYXBWYWx1ZSA9IGV4aXN0aW5nUmVzdWx0LmNhY2hlZFNjcm9sbFNuYXBWYWx1ZTtcbiAgICAgICAgICAgIGNhY2hlZFNjcm9sbEJlaGF2aW9yU3R5bGVBdHRyaWJ1dGVWYWx1ZSA9IGV4aXN0aW5nUmVzdWx0LmNhY2hlZFNjcm9sbEJlaGF2aW9yU3R5bGVBdHRyaWJ1dGVWYWx1ZTtcbiAgICAgICAgICAgIHNlY29uZGFyeVNjcm9sbGVyID0gZXhpc3RpbmdSZXN1bHQuc2Vjb25kYXJ5U2Nyb2xsZXI7XG4gICAgICAgICAgICBzZWNvbmRhcnlTY3JvbGxlckNhY2hlZFNjcm9sbFNuYXBWYWx1ZSA9IGV4aXN0aW5nUmVzdWx0LnNlY29uZGFyeVNjcm9sbGVyQ2FjaGVkU2Nyb2xsU25hcFZhbHVlO1xuICAgICAgICAgICAgc2Vjb25kYXJ5U2Nyb2xsZXJDYWNoZWRTY3JvbGxCZWhhdmlvclN0eWxlQXR0cmlidXRlVmFsdWUgPSBleGlzdGluZ1Jlc3VsdC5zZWNvbmRhcnlTY3JvbGxlckNhY2hlZFNjcm9sbEJlaGF2aW9yU3R5bGVBdHRyaWJ1dGVWYWx1ZTtcbiAgICAgICAgICAgIGV4aXN0aW5nUmVzdWx0LnJlbGVhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNjcm9sbFNuYXBWYWx1ZSA9IHNjcm9sbGVyLnN0eWxlLnNjcm9sbFNuYXBUeXBlID09PSBcIlwiID8gbnVsbCA6IHNjcm9sbGVyLnN0eWxlLnNjcm9sbFNuYXBUeXBlO1xuICAgICAgICAgICAgY2FjaGVkU2Nyb2xsQmVoYXZpb3JTdHlsZUF0dHJpYnV0ZVZhbHVlID0gcGFyc2VTY3JvbGxCZWhhdmlvckZyb21TdHlsZUF0dHJpYnV0ZShzY3JvbGxlcik7XG4gICAgICAgICAgICBzZWNvbmRhcnlTY3JvbGxlciA9IHNjcm9sbGVyID09PSBzY3JvbGxpbmdFbGVtZW50ICYmIHNjcm9sbGluZ0VsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkgPyBkb2N1bWVudC5ib2R5IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgc2Vjb25kYXJ5U2Nyb2xsZXJDYWNoZWRTY3JvbGxTbmFwVmFsdWUgPVxuICAgICAgICAgICAgICAgIHNlY29uZGFyeVNjcm9sbGVyID09IG51bGwgPyB1bmRlZmluZWQgOiBzZWNvbmRhcnlTY3JvbGxlci5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9PT0gXCJcIiA/IG51bGwgOiBzZWNvbmRhcnlTY3JvbGxlci5zdHlsZS5zY3JvbGxTbmFwVHlwZTtcbiAgICAgICAgICAgIHNlY29uZGFyeVNjcm9sbGVyQ2FjaGVkU2Nyb2xsQmVoYXZpb3JTdHlsZUF0dHJpYnV0ZVZhbHVlID1cbiAgICAgICAgICAgICAgICBzZWNvbmRhcnlTY3JvbGxlciA9PSBudWxsID8gdW5kZWZpbmVkIDogcGFyc2VTY3JvbGxCZWhhdmlvckZyb21TdHlsZUF0dHJpYnV0ZShzZWNvbmRhcnlTY3JvbGxlcik7XG4gICAgICAgICAgICB2YXIgY2FjaGVkQ29tcHV0ZWRTY3JvbGxTbmFwVmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlKHNjcm9sbGVyKS5nZXRQcm9wZXJ0eVZhbHVlKFwic2Nyb2xsLXNuYXAtdHlwZVwiKTtcbiAgICAgICAgICAgIHZhciBzZWNvbmRhcnlTY3JvbGxlckNhY2hlZENvbXB1dGVkU2Nyb2xsU25hcFZhbHVlID0gc2Vjb25kYXJ5U2Nyb2xsZXIgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGdldENvbXB1dGVkU3R5bGUoc2Vjb25kYXJ5U2Nyb2xsZXIpLmdldFByb3BlcnR5VmFsdWUoXCJzY3JvbGwtc25hcC10eXBlXCIpO1xuICAgICAgICAgICAgLy8gSWYgaXQganVzdCBzbyBoYXBwZW5zIHRoYXQgdGhlcmUgYWN0dWFsbHkgaXNuJ3QgYW55IHNjcm9sbCBzbmFwcGluZyBnb2luZyBvbiwgdGhlcmUncyBubyBwb2ludCBpbiBwZXJmb3JtaW5nIGFueSBhZGRpdGlvbmFsIHdvcmsgaGVyZS5cbiAgICAgICAgICAgIGlmIChjYWNoZWRDb21wdXRlZFNjcm9sbFNuYXBWYWx1ZSA9PT0gXCJub25lXCIgJiYgc2Vjb25kYXJ5U2Nyb2xsZXJDYWNoZWRDb21wdXRlZFNjcm9sbFNuYXBWYWx1ZSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTk9PUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY3JvbGxlci5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9IFwibm9uZVwiO1xuICAgICAgICBpZiAoc2Vjb25kYXJ5U2Nyb2xsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2Vjb25kYXJ5U2Nyb2xsZXIuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSBcIm5vbmVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGVkU2Nyb2xsQmVoYXZpb3JTdHlsZUF0dHJpYnV0ZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFwcGVuZFNjcm9sbEJlaGF2aW9yVG9TdHlsZUF0dHJpYnV0ZShzY3JvbGxlciwgY2FjaGVkU2Nyb2xsQmVoYXZpb3JTdHlsZUF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Vjb25kYXJ5U2Nyb2xsZXIgIT09IHVuZGVmaW5lZCAmJiBzZWNvbmRhcnlTY3JvbGxlckNhY2hlZFNjcm9sbEJlaGF2aW9yU3R5bGVBdHRyaWJ1dGVWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhcHBlbmRTY3JvbGxCZWhhdmlvclRvU3R5bGVBdHRyaWJ1dGUoc2Vjb25kYXJ5U2Nyb2xsZXIsIHNlY29uZGFyeVNjcm9sbGVyQ2FjaGVkU2Nyb2xsQmVoYXZpb3JTdHlsZUF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzUmVsZWFzZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gc2Nyb2xsZXIgPT09IHNjcm9sbGluZ0VsZW1lbnQgPyB3aW5kb3cgOiBzY3JvbGxlcjtcbiAgICAgICAgZnVuY3Rpb24gcmVsZWFzZSgpIHtcbiAgICAgICAgICAgIGV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgcmVzZXRIYW5kbGVyKTtcbiAgICAgICAgICAgIGlmIChtYXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1hcFtcImRlbGV0ZVwiXShzY3JvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXNSZWxlYXNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVzZXRIYW5kbGVyKCkge1xuICAgICAgICAgICAgc2Nyb2xsZXIuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSBjYWNoZWRTY3JvbGxTbmFwVmFsdWU7XG4gICAgICAgICAgICBpZiAoc2Vjb25kYXJ5U2Nyb2xsZXIgIT0gbnVsbCAmJiBzZWNvbmRhcnlTY3JvbGxlckNhY2hlZFNjcm9sbFNuYXBWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2Vjb25kYXJ5U2Nyb2xsZXIuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSBzZWNvbmRhcnlTY3JvbGxlckNhY2hlZFNjcm9sbFNuYXBWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWNoZWRTY3JvbGxCZWhhdmlvclN0eWxlQXR0cmlidXRlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFwcGVuZFNjcm9sbEJlaGF2aW9yVG9TdHlsZUF0dHJpYnV0ZShzY3JvbGxlciwgY2FjaGVkU2Nyb2xsQmVoYXZpb3JTdHlsZUF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWNvbmRhcnlTY3JvbGxlciAhPT0gdW5kZWZpbmVkICYmIHNlY29uZGFyeVNjcm9sbGVyQ2FjaGVkU2Nyb2xsQmVoYXZpb3JTdHlsZUF0dHJpYnV0ZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRTY3JvbGxCZWhhdmlvclRvU3R5bGVBdHRyaWJ1dGUoc2Vjb25kYXJ5U2Nyb2xsZXIsIHNlY29uZGFyeVNjcm9sbGVyQ2FjaGVkU2Nyb2xsQmVoYXZpb3JTdHlsZUF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNSZWxlYXNlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgcmVzZXRIYW5kbGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1hcC5zZXQoc2Nyb2xsZXIsIHtcbiAgICAgICAgICAgIHJlbGVhc2U6IHJlbGVhc2UsXG4gICAgICAgICAgICBjYWNoZWRTY3JvbGxTbmFwVmFsdWU6IGNhY2hlZFNjcm9sbFNuYXBWYWx1ZSxcbiAgICAgICAgICAgIGNhY2hlZFNjcm9sbEJlaGF2aW9yU3R5bGVBdHRyaWJ1dGVWYWx1ZTogY2FjaGVkU2Nyb2xsQmVoYXZpb3JTdHlsZUF0dHJpYnV0ZVZhbHVlLFxuICAgICAgICAgICAgc2Vjb25kYXJ5U2Nyb2xsZXI6IHNlY29uZGFyeVNjcm9sbGVyLFxuICAgICAgICAgICAgc2Vjb25kYXJ5U2Nyb2xsZXJDYWNoZWRTY3JvbGxTbmFwVmFsdWU6IHNlY29uZGFyeVNjcm9sbGVyQ2FjaGVkU2Nyb2xsU25hcFZhbHVlLFxuICAgICAgICAgICAgc2Vjb25kYXJ5U2Nyb2xsZXJDYWNoZWRTY3JvbGxCZWhhdmlvclN0eWxlQXR0cmlidXRlVmFsdWU6IHNlY29uZGFyeVNjcm9sbGVyQ2FjaGVkU2Nyb2xsQmVoYXZpb3JTdHlsZUF0dHJpYnV0ZVZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzZXQ6IHJlc2V0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGR1cmF0aW9uIG9mIGEgc21vb3RoIHNjcm9sbFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdmFyIFNDUk9MTF9USU1FID0gMTUwMDA7XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBzbW9vdGggcmVwb3NpdGlvbmluZyBvZiB0aGUgc2Nyb2xsXG4gICAgICogQHBhcmFtIHtJU21vb3RoU2Nyb2xsT3B0aW9uc30gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNtb290aFNjcm9sbChvcHRpb25zKSB7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBvcHRpb25zLnN0YXJ0VGltZSwgc3RhcnRYID0gb3B0aW9ucy5zdGFydFgsIHN0YXJ0WSA9IG9wdGlvbnMuc3RhcnRZLCBlbmRYID0gb3B0aW9ucy5lbmRYLCBlbmRZID0gb3B0aW9ucy5lbmRZLCBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCwgc2Nyb2xsZXIgPSBvcHRpb25zLnNjcm9sbGVyO1xuICAgICAgICB2YXIgdGltZUxhcHNlZCA9IDA7XG4gICAgICAgIHZhciBkaXN0YW5jZVggPSBlbmRYIC0gc3RhcnRYO1xuICAgICAgICB2YXIgZGlzdGFuY2VZID0gZW5kWSAtIHN0YXJ0WTtcbiAgICAgICAgdmFyIHNwZWVkID0gTWF0aC5tYXgoTWF0aC5hYnMoKGRpc3RhbmNlWCAvIDEwMDApICogU0NST0xMX1RJTUUpLCBNYXRoLmFicygoZGlzdGFuY2VZIC8gMTAwMCkgKiBTQ1JPTExfVElNRSkpO1xuICAgICAgICAvLyBUZW1wb3JhcmlseSBkaXNhYmxlcyBhbnkgc2Nyb2xsIHNuYXBwaW5nIHRoYXQgbWF5IGJlIGFjdGl2ZSBzaW5jZSBpdCBmaWdodHMgZm9yIGNvbnRyb2wgb3ZlciB0aGUgc2Nyb2xsZXIgd2l0aCB0aGlzIHBvbHlmaWxsXG4gICAgICAgIHZhciBzY3JvbGxTbmFwRml4ID0gZGlzYWJsZVNjcm9sbFNuYXAoc2Nyb2xsZXIpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gYW5pbWF0ZSh0aW1lc3RhbXApIHtcbiAgICAgICAgICAgIHRpbWVMYXBzZWQgKz0gdGltZXN0YW1wIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnRhZ2UgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBzcGVlZCA9PT0gMCA/IDAgOiB0aW1lTGFwc2VkIC8gc3BlZWQpKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvblggPSBNYXRoLmZsb29yKHN0YXJ0WCArIGRpc3RhbmNlWCAqIGVhc2UocGVyY2VudGFnZSkpO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uWSA9IE1hdGguZmxvb3Ioc3RhcnRZICsgZGlzdGFuY2VZICogZWFzZShwZXJjZW50YWdlKSk7XG4gICAgICAgICAgICBtZXRob2QocG9zaXRpb25YLCBwb3NpdGlvblkpO1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uWCAhPT0gZW5kWCB8fCBwb3NpdGlvblkgIT09IGVuZFkpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsU25hcEZpeCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFNuYXBGaXgucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsU25hcEZpeCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBIaWdoIFJlc29sdXRpb24gdGltZXN0YW1wIGlmIHBvc3NpYmxlLCBvdGhlcndpc2UgZmFsbGJhY2tzIHRvIERhdGUubm93KClcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vdygpIHtcbiAgICAgICAgaWYgKFwicGVyZm9ybWFuY2VcIiBpbiB3aW5kb3cpXG4gICAgICAgICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpO1xuICAgIH1cblxuICAgIFxuXG4gICAgdmFyIEVMRU1FTlRfT1JJR0lOQUxfU0NST0xMID0gVU5TVVBQT1JURURfRU5WSVJPTk1FTlQgPyB1bmRlZmluZWQgOiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGw7XG5cbiAgICB2YXIgV0lORE9XX09SSUdJTkFMX1NDUk9MTCA9IFVOU1VQUE9SVEVEX0VOVklST05NRU5UID8gdW5kZWZpbmVkIDogd2luZG93LnNjcm9sbDtcblxuICAgIHZhciBFTEVNRU5UX09SSUdJTkFMX1NDUk9MTF9CWSA9IFVOU1VQUE9SVEVEX0VOVklST05NRU5UID8gdW5kZWZpbmVkIDogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsQnk7XG5cbiAgICB2YXIgV0lORE9XX09SSUdJTkFMX1NDUk9MTF9CWSA9IFVOU1VQUE9SVEVEX0VOVklST05NRU5UID8gdW5kZWZpbmVkIDogd2luZG93LnNjcm9sbEJ5O1xuXG4gICAgdmFyIEVMRU1FTlRfT1JJR0lOQUxfU0NST0xMX1RPID0gVU5TVVBQT1JURURfRU5WSVJPTk1FTlQgPyB1bmRlZmluZWQgOiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxUbztcblxuICAgIHZhciBXSU5ET1dfT1JJR0lOQUxfU0NST0xMX1RPID0gVU5TVVBQT1JURURfRU5WSVJPTk1FTlQgPyB1bmRlZmluZWQgOiB3aW5kb3cuc2Nyb2xsVG87XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGlmIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbCBpcyBub3QgZGVmaW5lZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbGVtZW50UHJvdG90eXBlU2Nyb2xsRmFsbGJhY2soeCwgeSkge1xuICAgICAgICB0aGlzLl9fYWRqdXN0aW5nU2Nyb2xsUG9zaXRpb24gPSB0cnVlO1xuICAgICAgICB0aGlzLnNjcm9sbExlZnQgPSB4O1xuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9fYWRqdXN0aW5nU2Nyb2xsUG9zaXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaWYgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsVG8gaXMgbm90IGRlZmluZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZWxlbWVudFByb3RvdHlwZVNjcm9sbFRvRmFsbGJhY2soeCwgeSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudFByb3RvdHlwZVNjcm9sbEZhbGxiYWNrLmNhbGwodGhpcywgeCwgeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaWYgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsQnkgaXMgbm90IGRlZmluZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZWxlbWVudFByb3RvdHlwZVNjcm9sbEJ5RmFsbGJhY2soeCwgeSkge1xuICAgICAgICB0aGlzLl9fYWRqdXN0aW5nU2Nyb2xsUG9zaXRpb24gPSB0cnVlO1xuICAgICAgICB0aGlzLnNjcm9sbExlZnQgKz0geDtcbiAgICAgICAgdGhpcy5zY3JvbGxUb3AgKz0geTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX19hZGp1c3RpbmdTY3JvbGxQb3NpdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgb3JpZ2luYWwgbm9uLXBhdGNoZWQgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGdpdmVuIGtpbmRcbiAgICAgKiBAcGFyYW0ge1Njcm9sbE1ldGhvZE5hbWV9IGtpbmRcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8V2luZG93fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0T3JpZ2luYWxTY3JvbGxNZXRob2RGb3JLaW5kKGtpbmQsIGVsZW1lbnQpIHtcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwic2Nyb2xsXCI6XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChFTEVNRU5UX09SSUdJTkFMX1NDUk9MTCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRUxFTUVOVF9PUklHSU5BTF9TQ1JPTEw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudFByb3RvdHlwZVNjcm9sbEZhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gV0lORE9XX09SSUdJTkFMX1NDUk9MTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic2Nyb2xsQnlcIjpcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVMRU1FTlRfT1JJR0lOQUxfU0NST0xMX0JZICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBFTEVNRU5UX09SSUdJTkFMX1NDUk9MTF9CWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50UHJvdG90eXBlU2Nyb2xsQnlGYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFdJTkRPV19PUklHSU5BTF9TQ1JPTExfQlk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInNjcm9sbFRvXCI6XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChFTEVNRU5UX09SSUdJTkFMX1NDUk9MTF9UTyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRUxFTUVOVF9PUklHSU5BTF9TQ1JPTExfVE87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudFByb3RvdHlwZVNjcm9sbFRvRmFsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBXSU5ET1dfT1JJR0lOQUxfU0NST0xMX1RPO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFNtb290aCBTY3JvbGwgT3B0aW9ucyB0byB1c2UgZm9yIHRoZSBzdGVwIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtFbGVtZW50fFdpbmRvd30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge1Njcm9sbE1ldGhvZE5hbWV9IGtpbmRcbiAgICAgKiBAcmV0dXJucyB7SVNtb290aFNjcm9sbE9wdGlvbnN9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U21vb3RoU2Nyb2xsT3B0aW9ucyhlbGVtZW50LCB4LCB5LCBraW5kKSB7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBub3coKTtcbiAgICAgICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAvLyBVc2Ugd2luZG93IGFzIHRoZSBzY3JvbGwgY29udGFpbmVyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsWF8xID0gd2luZG93LnNjcm9sbFgsIHBhZ2VYT2Zmc2V0XzEgPSB3aW5kb3cucGFnZVhPZmZzZXQsIHNjcm9sbFlfMSA9IHdpbmRvdy5zY3JvbGxZLCBwYWdlWU9mZnNldF8xID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IHNjcm9sbFhfMSA9PSBudWxsIHx8IHNjcm9sbFhfMSA9PT0gMCA/IHBhZ2VYT2Zmc2V0XzEgOiBzY3JvbGxYXzE7XG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gc2Nyb2xsWV8xID09IG51bGwgfHwgc2Nyb2xsWV8xID09PSAwID8gcGFnZVlPZmZzZXRfMSA6IHNjcm9sbFlfMTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgc3RhcnRYOiBzdGFydFgsXG4gICAgICAgICAgICAgICAgc3RhcnRZOiBzdGFydFksXG4gICAgICAgICAgICAgICAgZW5kWDogTWF0aC5mbG9vcihraW5kID09PSBcInNjcm9sbEJ5XCIgPyBzdGFydFggKyB4IDogeCksXG4gICAgICAgICAgICAgICAgZW5kWTogTWF0aC5mbG9vcihraW5kID09PSBcInNjcm9sbEJ5XCIgPyBzdGFydFkgKyB5IDogeSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBnZXRPcmlnaW5hbFNjcm9sbE1ldGhvZEZvcktpbmQoXCJzY3JvbGxUb1wiLCB3aW5kb3cpLmJpbmQod2luZG93KSxcbiAgICAgICAgICAgICAgICBzY3JvbGxlcjogZ2V0U2Nyb2xsaW5nRWxlbWVudCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQsIHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IHNjcm9sbExlZnQ7XG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBzdGFydFg6IHN0YXJ0WCxcbiAgICAgICAgICAgICAgICBzdGFydFk6IHN0YXJ0WSxcbiAgICAgICAgICAgICAgICBlbmRYOiBNYXRoLmZsb29yKGtpbmQgPT09IFwic2Nyb2xsQnlcIiA/IHN0YXJ0WCArIHggOiB4KSxcbiAgICAgICAgICAgICAgICBlbmRZOiBNYXRoLmZsb29yKGtpbmQgPT09IFwic2Nyb2xsQnlcIiA/IHN0YXJ0WSArIHkgOiB5KSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGdldE9yaWdpbmFsU2Nyb2xsTWV0aG9kRm9yS2luZChcInNjcm9sbFRvXCIsIGVsZW1lbnQpLmJpbmQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXI6IGVsZW1lbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIG51bWVyaWNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5zdXJlTnVtZXJpYyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBzb21lIFNjcm9sbFRvT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyIHwgU2Nyb2xsVG9PcHRpb25zfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge3ZhbHVlIGlzIFNjcm9sbFRvT3B0aW9uc31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Njcm9sbFRvT3B0aW9ucyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhIHNjcm9sbCBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8V2luZG93fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTY3JvbGxNZXRob2ROYW1lfSBraW5kXG4gICAgICogQHBhcmFtIHtudW1iZXIgfCBTY3JvbGxUb09wdGlvbnN9IG9wdGlvbnNPclhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhbmRsZVNjcm9sbE1ldGhvZChlbGVtZW50LCBraW5kLCBvcHRpb25zT3JYLCB5KSB7XG4gICAgICAgIG9uU2Nyb2xsV2l0aE9wdGlvbnMoZ2V0U2Nyb2xsVG9PcHRpb25zV2l0aFZhbGlkYXRpb24ob3B0aW9uc09yWCwgeSksIGVsZW1lbnQsIGtpbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gYSAnU2Nyb2xsVG9PcHRpb25zJyBkaWN0IGlzIHByb3ZpZGVkIHRvICdzY3JvbGwoKScgYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtTY3JvbGxUb09wdGlvbnN9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8V2luZG93fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTY3JvbGxNZXRob2ROYW1lfSBraW5kXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25TY3JvbGxXaXRoT3B0aW9ucyhvcHRpb25zLCBlbGVtZW50LCBraW5kKSB7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IGdldFNjcm9sbEJlaGF2aW9yKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJZiB0aGUgYmVoYXZpb3IgaXMgJ2F1dG8nIGFwcGx5IGluc3RhbnRhbmVvdXMgc2Nyb2xsaW5nXG4gICAgICAgIGlmIChiZWhhdmlvciA9PSBudWxsIHx8IGJlaGF2aW9yID09PSBcImF1dG9cIikge1xuICAgICAgICAgICAgZ2V0T3JpZ2luYWxTY3JvbGxNZXRob2RGb3JLaW5kKGtpbmQsIGVsZW1lbnQpLmNhbGwoZWxlbWVudCwgb3B0aW9ucy5sZWZ0LCBvcHRpb25zLnRvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzbW9vdGhTY3JvbGwoZ2V0U21vb3RoU2Nyb2xsT3B0aW9ucyhlbGVtZW50LCBvcHRpb25zLmxlZnQsIG9wdGlvbnMudG9wLCBraW5kKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gc2Nyb2xsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtudW1iZXI/fSB4XG4gICAgICogQHBhcmFtIHtudW1iZXI/fSB5XG4gICAgICogQHJldHVybiB7UmVxdWlyZWQ8UGljazxTY3JvbGxUb09wdGlvbnMsIFwidG9wXCIgfCBcImxlZnRcIj4+fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVNjcm9sbENvb3JkaW5hdGVzKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGVuc3VyZU51bWVyaWMoeCksXG4gICAgICAgICAgICB0b3A6IGVuc3VyZU51bWVyaWMoeSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBTY3JvbGxUb09wdGlvbnMgYmFzZWQgb24gdGhlIGdpdmVuIGFyZ3VtZW50cy4gV2lsbCB0aHJvdyBpZiB2YWxpZGF0aW9uIGZhaWxzXG4gICAgICogQHBhcmFtIHtudW1iZXIgfCBTY3JvbGxUb09wdGlvbnN9IG9wdGlvbnNPclhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm4ge1JlcXVpcmVkPFNjcm9sbFRvT3B0aW9ucz59XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2Nyb2xsVG9PcHRpb25zV2l0aFZhbGlkYXRpb24ob3B0aW9uc09yWCwgeSkge1xuICAgICAgICAvLyBJZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBnaXZlbiwgYW5kIGl0IGlzbid0IGFuIG9wdGlvbnMgb2JqZWN0LCB0aHJvdyBhIFR5cGVFcnJvclxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkICYmICFpc1Njcm9sbFRvT3B0aW9ucyhvcHRpb25zT3JYKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICdzY3JvbGwnIG9uICdFbGVtZW50JzogcGFyYW1ldGVyIDEgKCdvcHRpb25zJykgaXMgbm90IGFuIG9iamVjdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2Nyb2xsIGJhc2VkIG9uIHRoZSBwcmltaXRpdmUgdmFsdWVzIGdpdmVuIGFzIGFyZ3VtZW50c1xuICAgICAgICBpZiAoIWlzU2Nyb2xsVG9PcHRpb25zKG9wdGlvbnNPclgpKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIG5vcm1hbGl6ZVNjcm9sbENvb3JkaW5hdGVzKG9wdGlvbnNPclgsIHkpKSwgeyBiZWhhdmlvcjogXCJhdXRvXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2Nyb2xsIGJhc2VkIG9uIHRoZSByZWNlaXZlZCBvcHRpb25zIG9iamVjdFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbm9ybWFsaXplU2Nyb2xsQ29vcmRpbmF0ZXMob3B0aW9uc09yWC5sZWZ0LCBvcHRpb25zT3JYLnRvcCkpLCB7IGJlaGF2aW9yOiBvcHRpb25zT3JYLmJlaGF2aW9yID09IG51bGwgPyBcImF1dG9cIiA6IG9wdGlvbnNPclguYmVoYXZpb3IgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXRjaGVzIHRoZSAnc2Nyb2xsJyBtZXRob2Qgb24gdGhlIEVsZW1lbnQgcHJvdG90eXBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGF0Y2hFbGVtZW50U2Nyb2xsKCkge1xuICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgPSBmdW5jdGlvbiAob3B0aW9uc09yWCwgeSkge1xuICAgICAgICAgICAgaGFuZGxlU2Nyb2xsTWV0aG9kKHRoaXMsIFwic2Nyb2xsXCIsIG9wdGlvbnNPclgsIHkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdGNoZXMgdGhlICdzY3JvbGxCeScgbWV0aG9kIG9uIHRoZSBFbGVtZW50IHByb3RvdHlwZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhdGNoRWxlbWVudFNjcm9sbEJ5KCkge1xuICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxCeSA9IGZ1bmN0aW9uIChvcHRpb25zT3JYLCB5KSB7XG4gICAgICAgICAgICBoYW5kbGVTY3JvbGxNZXRob2QodGhpcywgXCJzY3JvbGxCeVwiLCBvcHRpb25zT3JYLCB5KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXRjaGVzIHRoZSAnc2Nyb2xsVG8nIG1ldGhvZCBvbiB0aGUgRWxlbWVudCBwcm90b3R5cGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXRjaEVsZW1lbnRTY3JvbGxUbygpIHtcbiAgICAgICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsVG8gPSBmdW5jdGlvbiAob3B0aW9uc09yWCwgeSkge1xuICAgICAgICAgICAgaGFuZGxlU2Nyb2xsTWV0aG9kKHRoaXMsIFwic2Nyb2xsVG9cIiwgb3B0aW9uc09yWCwgeSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF0Y2hlcyB0aGUgJ3Njcm9sbCcgbWV0aG9kIG9uIHRoZSBXaW5kb3cgcHJvdG90eXBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGF0Y2hXaW5kb3dTY3JvbGwoKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGwgPSBmdW5jdGlvbiAob3B0aW9uc09yWCwgeSkge1xuICAgICAgICAgICAgaGFuZGxlU2Nyb2xsTWV0aG9kKHRoaXMsIFwic2Nyb2xsXCIsIG9wdGlvbnNPclgsIHkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdGNoZXMgdGhlICdzY3JvbGxCeScgbWV0aG9kIG9uIHRoZSBXaW5kb3cgcHJvdG90eXBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGF0Y2hXaW5kb3dTY3JvbGxCeSgpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbEJ5ID0gZnVuY3Rpb24gKG9wdGlvbnNPclgsIHkpIHtcbiAgICAgICAgICAgIGhhbmRsZVNjcm9sbE1ldGhvZCh0aGlzLCBcInNjcm9sbEJ5XCIsIG9wdGlvbnNPclgsIHkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdGNoZXMgdGhlICdzY3JvbGxUbycgbWV0aG9kIG9uIHRoZSBXaW5kb3cgcHJvdG90eXBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGF0Y2hXaW5kb3dTY3JvbGxUbygpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvID0gZnVuY3Rpb24gKG9wdGlvbnNPclgsIHkpIHtcbiAgICAgICAgICAgIGhhbmRsZVNjcm9sbE1ldGhvZCh0aGlzLCBcInNjcm9sbFRvXCIsIG9wdGlvbnNPclgsIHkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIHRzbGludDpkaXNhYmxlOm5vLWFueVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhcmVudCBvZiBhbiBlbGVtZW50LCB0YWtpbmcgaW50byBhY2NvdW50IERvY3VtZW50RnJhZ21lbnRzLCBTaGFkb3dSb290cywgYXMgd2VsbCBhcyB0aGUgcm9vdCBjb250ZXh0ICh3aW5kb3cpXG4gICAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gY3VycmVudEVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRUYXJnZXQgfCBudWxsfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBhcmVudChjdXJyZW50RWxlbWVudCkge1xuICAgICAgICBpZiAoXCJub2RlVHlwZVwiIGluIGN1cnJlbnRFbGVtZW50ICYmIGN1cnJlbnRFbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJTaGFkb3dSb290XCIgaW4gd2luZG93ICYmIGN1cnJlbnRFbGVtZW50IGluc3RhbmNlb2Ygd2luZG93LlNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRFbGVtZW50ID09PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50RWxlbWVudCBpbnN0YW5jZW9mIE5vZGUpXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvdmVyZmxvdyBwcm9wZXJ0eSByZXByZXNlbnRzIGEgc2Nyb2xsYWJsZSBvdmVyZmxvdyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gb3ZlcmZsb3dcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbk92ZXJmbG93KG92ZXJmbG93KSB7XG4gICAgICAgIHJldHVybiBvdmVyZmxvdyAhPT0gXCJ2aXNpYmxlXCIgJiYgb3ZlcmZsb3cgIT09IFwiY2xpcFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgc2Nyb2xsYWJsZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTY3JvbGxhYmxlKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuY2xpZW50SGVpZ2h0IDwgZWxlbWVudC5zY3JvbGxIZWlnaHQgfHwgZWxlbWVudC5jbGllbnRXaWR0aCA8IGVsZW1lbnQuc2Nyb2xsV2lkdGgpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gY2FuT3ZlcmZsb3coc3R5bGUub3ZlcmZsb3dZKSB8fCBjYW5PdmVyZmxvdyhzdHlsZS5vdmVyZmxvd1gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIG5lYXJlc3QgYW5jZXN0b3Igb2YgYW4gZWxlbWVudCB0aGF0IGNhbiBzY3JvbGxcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fFdpbmRvdz99XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZE5lYXJlc3RBbmNlc3RvcnNXaXRoU2Nyb2xsQmVoYXZpb3IodGFyZ2V0KSB7XG4gICAgICAgIHZhciBjdXJyZW50RWxlbWVudCA9IHRhcmdldDtcbiAgICAgICAgdmFyIHNjcm9sbGluZ0VsZW1lbnQgPSBnZXRTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgICAgIHdoaWxlIChjdXJyZW50RWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgYmVoYXZpb3IgPSBnZXRTY3JvbGxCZWhhdmlvcihjdXJyZW50RWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoYmVoYXZpb3IgIT0gbnVsbCAmJiAoY3VycmVudEVsZW1lbnQgPT09IHNjcm9sbGluZ0VsZW1lbnQgfHwgaXNTY3JvbGxhYmxlKGN1cnJlbnRFbGVtZW50KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2N1cnJlbnRFbGVtZW50LCBiZWhhdmlvcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBnZXRQYXJlbnQoY3VycmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQgPSBwYXJlbnRfMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBzdWNoIGVsZW1lbnQgY291bGQgYmUgZm91bmQuIFN0YXJ0IG92ZXIsIGJ1dCB0aGlzIHRpbWUgZmluZCB0aGUgbmVhcmVzdCBhbmNlc3RvciB0aGF0IGNhbiBzaW1wbHkgc2Nyb2xsXG4gICAgICAgIGN1cnJlbnRFbGVtZW50ID0gdGFyZ2V0O1xuICAgICAgICB3aGlsZSAoY3VycmVudEVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50ID09PSBzY3JvbGxpbmdFbGVtZW50IHx8IGlzU2Nyb2xsYWJsZShjdXJyZW50RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2N1cnJlbnRFbGVtZW50LCBcImF1dG9cIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFyZW50XzIgPSBnZXRQYXJlbnQoY3VycmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQgPSBwYXJlbnRfMjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWZhdWx0IHRvIHRoZSBzY3JvbGxpbmcgZWxlbWVudFxuICAgICAgICByZXR1cm4gW3Njcm9sbGluZ0VsZW1lbnQsIFwiYXV0b1wiXTtcbiAgICB9XG5cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZTpuby1hbnlcbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbmVhcmVzdCByb290IGZyb20gYW4gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gICAgICogQHJldHVybnMge0RvY3VtZW50fFNoYWRvd1Jvb3R9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZE5lYXJlc3RSb290KHRhcmdldCkge1xuICAgICAgICB2YXIgY3VycmVudEVsZW1lbnQgPSB0YXJnZXQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50RWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoXCJTaGFkb3dSb290XCIgaW4gd2luZG93ICYmIGN1cnJlbnRFbGVtZW50IGluc3RhbmNlb2Ygd2luZG93LlNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAvLyBBc3N1bWUgdGhpcyBpcyBhIFNoYWRvd1Jvb3RcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBnZXRQYXJlbnQoY3VycmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudF8xID09PSBjdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gcGFyZW50XzE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG9yaWdpbiBvZiB0aGUgZ2l2ZW4gTG9jYXRpb24gb3IgSFRNTEFuY2hvckVsZW1lbnQgaWYgYXZhaWxhYmxlIGluIHRoZSBydW50aW1lLCBhbmQgb3RoZXJ3aXNlIHNoaW1zIGl0LiAoaXQncyBhIG9uZS1saW5lcilcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldExvY2F0aW9uT3JpZ2luKGxvY2F0aW9uTGlrZSkge1xuICAgICAgICBpZiAobG9jYXRpb25MaWtlID09PSB2b2lkIDApIHsgbG9jYXRpb25MaWtlID0gbG9jYXRpb247IH1cbiAgICAgICAgaWYgKFwib3JpZ2luXCIgaW4gbG9jYXRpb25MaWtlICYmIGxvY2F0aW9uTGlrZS5vcmlnaW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2F0aW9uTGlrZS5vcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvcnQgPSBsb2NhdGlvbkxpa2UucG9ydCAhPSBudWxsICYmIGxvY2F0aW9uTGlrZS5wb3J0Lmxlbmd0aCA+IDAgPyBcIjpcIiArIGxvY2F0aW9uTGlrZS5wb3J0IDogXCJcIjtcbiAgICAgICAgaWYgKGxvY2F0aW9uTGlrZS5wcm90b2NvbCA9PT0gXCJodHRwOlwiICYmIHBvcnQgPT09IFwiOjgwXCIpIHtcbiAgICAgICAgICAgIHBvcnQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxvY2F0aW9uTGlrZS5wcm90b2NvbCA9PT0gXCJodHRwczpcIiAmJiBwb3J0ID09PSBcIjo0NDNcIikge1xuICAgICAgICAgICAgcG9ydCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uTGlrZS5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uTGlrZS5ob3N0bmFtZSArIHBvcnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGlkJ3Mgb2YgdGhlIGZvcm0gXCIjW2RpZ2l0XVwiXG4gICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgKi9cbiAgICB2YXIgSURfV0lUSF9MRUFESU5HX0RJR0lUX1JFR0VYUCA9IC9eI1xcZC87XG4gICAgLyoqXG4gICAgICogQ2F0Y2hlcyBhbmNob3IgbmF2aWdhdGlvbiB0byBJRHMgd2l0aGluIHRoZSBzYW1lIHJvb3QgYW5kIGVuc3VyZXMgdGhhdCB0aGV5IGNhbiBiZSBzbW9vdGgtc2Nyb2xsZWRcbiAgICAgKiBpZiB0aGUgc2Nyb2xsIGJlaGF2aW9yIGlzIHNtb290aCBpbiB0aGUgZmlyc3Qgcm9vdGVyIHdpdGhpbiB0aGF0IGNvbnRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXRjaE5hdmlnYXRpb24oKSB7XG4gICAgICAgIC8vIExpc3RlbiBmb3IgJ2NsaWNrJyBldmVudHMgZ2xvYmFsbHlcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8gT25seSB3b3JrIHdpdGggdHJ1c3RlZCBldmVudHMgb24gSFRNTEFuY2hvckVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIWUuaXNUcnVzdGVkIHx8ICEoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIF9hID0gZS50YXJnZXQsIHBhdGhuYW1lID0gX2EucGF0aG5hbWUsIHNlYXJjaCA9IF9hLnNlYXJjaCwgaGFzaCA9IF9hLmhhc2g7XG4gICAgICAgICAgICB2YXIgcG9pbnRzVG9DdXJyZW50UGFnZSA9IGdldExvY2F0aW9uT3JpZ2luKGUudGFyZ2V0KSA9PT0gZ2V0TG9jYXRpb25PcmlnaW4obG9jYXRpb24pICYmIHBhdGhuYW1lID09PSBsb2NhdGlvbi5wYXRobmFtZSAmJiBzZWFyY2ggPT09IGxvY2F0aW9uLnNlYXJjaDtcbiAgICAgICAgICAgIC8vIE9ubHkgd29yayB3aXRoIEhUTUxBbmNob3JFbGVtZW50cyB0aGF0IG5hdmlnYXRlcyB0byBhIHNwZWNpZmljIElEIG9uIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgIGlmICghcG9pbnRzVG9DdXJyZW50UGFnZSB8fCBoYXNoID09IG51bGwgfHwgaGFzaC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluZCB0aGUgbmVhcmVzdCByb290LCB3aGV0aGVyIGl0IGJlIGEgU2hhZG93Um9vdCBvciB0aGUgZG9jdW1lbnQgaXRzZWxmXG4gICAgICAgICAgICB2YXIgcm9vdCA9IGZpbmROZWFyZXN0Um9vdChlLnRhcmdldCk7XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIG1hdGNoIHRoZSBzZWxlY3RvciBmcm9tIHRoYXQgcm9vdC4gcXVlcnlTZWxlY3RvcicgZG9lc24ndCBzdXBwb3J0IElEcyB0aGF0IHN0YXJ0IHdpdGggYSBkaWdpdCwgc28gd29yayBhcm91bmQgdGhhdCBsaW1pdGF0aW9uXG4gICAgICAgICAgICB2YXIgZWxlbWVudE1hdGNoID0gaGFzaC5tYXRjaChJRF9XSVRIX0xFQURJTkdfRElHSVRfUkVHRVhQKSAhPSBudWxsID8gcm9vdC5nZXRFbGVtZW50QnlJZChoYXNoLnNsaWNlKDEpKSA6IHJvb3QucXVlcnlTZWxlY3RvcihoYXNoKTtcbiAgICAgICAgICAgIC8vIElmIG5vIHNlbGVjdG9yIGNvdWxkIGJlIGZvdW5kLCBkb24ndCBwcm9jZWVkXG4gICAgICAgICAgICBpZiAoZWxlbWVudE1hdGNoID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgbmVhcmVzdCBhbmNlc3RvciB0aGF0IGNhbiBiZSBzY3JvbGxlZFxuICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKGZpbmROZWFyZXN0QW5jZXN0b3JzV2l0aFNjcm9sbEJlaGF2aW9yKGVsZW1lbnRNYXRjaCksIDIpLCBiZWhhdmlvciA9IF9iWzFdO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGJlaGF2aW9yIGlzbid0IHNtb290aCwgZG9uJ3QgcHJvY2VlZFxuICAgICAgICAgICAgaWYgKGJlaGF2aW9yICE9PSBcInNtb290aFwiKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZmlyc3QgcHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb24uXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAvLyBOb3csIHNjcm9sbCB0byB0aGUgZWxlbWVudCB3aXRoIHRoYXQgSURcbiAgICAgICAgICAgIGVsZW1lbnRNYXRjaC5zY3JvbGxJbnRvVmlldyh7XG4gICAgICAgICAgICAgICAgYmVoYXZpb3I6IGJlaGF2aW9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIEVMRU1FTlRfT1JJR0lOQUxfU0NST0xMX0lOVE9fVklFVyA9IFVOU1VQUE9SVEVEX0VOVklST05NRU5UID8gdW5kZWZpbmVkIDogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWFqb3JpdHkgb2YgdGhpcyBmaWxlIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9zdGlwc2FuL2NvbXB1dGUtc2Nyb2xsLWludG8tdmlldyAoTUlUIGxpY2Vuc2UpLFxuICAgICAqIGJ1dCBoYXMgYmVlbiByZXdyaXR0ZW4gdG8gYWNjZXB0IGEgc2Nyb2xsZXIgYXMgYW4gYXJndW1lbnQuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogRmluZCBvdXQgd2hpY2ggZWRnZSB0byBhbGlnbiBhZ2FpbnN0IHdoZW4gbG9naWNhbCBzY3JvbGwgcG9zaXRpb24gaXMgXCJuZWFyZXN0XCJcbiAgICAgKiBJbnRlcmVzdGluZyBmYWN0OiBcIm5lYXJlc3RcIiB3b3JrcyBzaW1pbGFybHkgdG8gXCJpZi1uZWVkZWRcIiwgaWYgdGhlIGVsZW1lbnQgaXMgZnVsbHkgdmlzaWJsZSBpdCB3aWxsIG5vdCBzY3JvbGwgaXRcbiAgICAgKlxuICAgICAqIExlZ2VuZHM6XG4gICAgICog4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQIOKUjyDilIEg4pSBIOKUgSDilJNcbiAgICAgKiDilIIgdGFyZ2V0IOKUgiAgIGZyYW1lXG4gICAgICog4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIOKUlyDilIEg4pSBIOKUgSDilJtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbGlnbk5lYXJlc3Qoc2Nyb2xsaW5nRWRnZVN0YXJ0LCBzY3JvbGxpbmdFZGdlRW5kLCBzY3JvbGxpbmdTaXplLCBzY3JvbGxpbmdCb3JkZXJTdGFydCwgc2Nyb2xsaW5nQm9yZGVyRW5kLCBlbGVtZW50RWRnZVN0YXJ0LCBlbGVtZW50RWRnZUVuZCwgZWxlbWVudFNpemUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGVsZW1lbnQgZWRnZSBBIGFuZCBlbGVtZW50IGVkZ2UgQiBhcmUgYm90aCBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBBIGFuZCBzY3JvbGxpbmcgYm94IGVkZ2UgQlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgICDilIzilIDilIDilJBcbiAgICAgICAgICogICAgICAgIOKUj+KUgeKUguKUgeKUgeKUguKUgeKUk1xuICAgICAgICAgKiAgICAgICAgICDilIIgIOKUglxuICAgICAgICAgKiAgICAgICAg4pSDIOKUgiAg4pSCIOKUgyAgICAgICAgZG8gbm90aGluZ1xuICAgICAgICAgKiAgICAgICAgICDilIIgIOKUglxuICAgICAgICAgKiAgICAgICAg4pSX4pSB4pSC4pSB4pSB4pSC4pSB4pSbXG4gICAgICAgICAqICAgICAgICAgIOKUlOKUgOKUgOKUmFxuICAgICAgICAgKlxuICAgICAgICAgKiAgSWYgZWxlbWVudCBlZGdlIEMgYW5kIGVsZW1lbnQgZWRnZSBEIGFyZSBib3RoIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEMgYW5kIHNjcm9sbGluZyBib3ggZWRnZSBEXG4gICAgICAgICAqXG4gICAgICAgICAqICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTXG4gICAgICAgICAqICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gICAgICAgICAqICAg4pSC4pSDICAgICAgICAg4pSD4pSCICAgICAgICBkbyBub3RoaW5nXG4gICAgICAgICAqICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAgICAgICAqICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoKGVsZW1lbnRFZGdlU3RhcnQgPCBzY3JvbGxpbmdFZGdlU3RhcnQgJiYgZWxlbWVudEVkZ2VFbmQgPiBzY3JvbGxpbmdFZGdlRW5kKSB8fFxuICAgICAgICAgICAgKGVsZW1lbnRFZGdlU3RhcnQgPiBzY3JvbGxpbmdFZGdlU3RhcnQgJiYgZWxlbWVudEVkZ2VFbmQgPCBzY3JvbGxpbmdFZGdlRW5kKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGVsZW1lbnQgZWRnZSBBIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEEgYW5kIGVsZW1lbnQgaGVpZ2h0IGlzIGxlc3MgdGhhbiBzY3JvbGxpbmcgYm94IGhlaWdodFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgICDilIzilIDilIDilJBcbiAgICAgICAgICogICAgICAgIOKUj+KUgeKUguKUgeKUgeKUguKUgeKUkyAgICAgICAgIOKUj+KUgeKUjOKUgeKUgeKUkOKUgeKUk1xuICAgICAgICAgKiAgICAgICAgICDilJTilIDilIDilJggICAgICAgICAgICAg4pSCICDilIJcbiAgICAgICAgICogIGZyb20gIOKUgyAgICAgIOKUgyAgICAgdG8gIOKUgyDilJTilIDilIDilJgg4pSDXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICDilJfilIEg4pSB4pSBIOKUgeKUmyAgICAgICAgIOKUl+KUgSDilIHilIEg4pSB4pSbXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGVsZW1lbnQgZWRnZSBCIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEIgYW5kIGVsZW1lbnQgaGVpZ2h0IGlzIGdyZWF0ZXIgdGhhbiBzY3JvbGxpbmcgYm94IGhlaWdodFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAg4pSP4pSBIOKUgeKUgSDilIHilJMgICAgICAgICDilI/ilIHilIzilIHilIHilJDilIHilJNcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgIOKUglxuICAgICAgICAgKiAgZnJvbSAg4pSDIOKUjOKUgOKUgOKUkCDilIMgICAgIHRvICDilIMg4pSCICDilIIg4pSDXG4gICAgICAgICAqICAgICAgICAgIOKUgiAg4pSCICAgICAgICAgICAgIOKUgiAg4pSCXG4gICAgICAgICAqICAgICAgICDilJfilIHilILilIHilIHilILilIHilJsgICAgICAgICDilJfilIHilILilIHilIHilILilIHilJtcbiAgICAgICAgICogICAgICAgICAg4pSCICDilIIgICAgICAgICAgICAg4pSU4pSA4pSA4pSYXG4gICAgICAgICAqICAgICAgICAgIOKUgiAg4pSCXG4gICAgICAgICAqICAgICAgICAgIOKUlOKUgOKUgOKUmFxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBlbGVtZW50IGVkZ2UgQyBpcyBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBDIGFuZCBlbGVtZW50IHdpZHRoIGlzIGxlc3MgdGhhbiBzY3JvbGxpbmcgYm94IHdpZHRoXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgIGZyb20gICAgICAgICAgICAgICAgIHRvXG4gICAgICAgICAqICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTICAgICAgICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJNcbiAgICAgICAgICogIOKUjOKUgOKUgOKUgOKUkCAgICAgICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSQXG4gICAgICAgICAqICDilIIg4pSDIOKUgiAgICAgICDilIMgICAgICAgICDilIMgICDilIIgICAgIOKUg1xuICAgICAgICAgKiAg4pSU4pSA4pSA4pSA4pSYICAgICAgICAgICAgICAgICDilJTilIDilIDilIDilJhcbiAgICAgICAgICogICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJsgICAgICAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUm1xuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBlbGVtZW50IGVkZ2UgRCBpcyBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBEIGFuZCBlbGVtZW50IHdpZHRoIGlzIGdyZWF0ZXIgdGhhbiBzY3JvbGxpbmcgYm94IHdpZHRoXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgIGZyb20gICAgICAgICAgICAgICAgIHRvXG4gICAgICAgICAqICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTICAgICAgICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJNcbiAgICAgICAgICogICAgICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgICAgICAgKiAgICDilIMgICDilIIgICAgIOKUgyAgICAg4pSCICAg4pSDICAgICAgICAg4pSDIOKUglxuICAgICAgICAgKiAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAgICAgICAqICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbICAgICAgICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJtcbiAgICAgICAgICovXG4gICAgICAgIGlmICgoZWxlbWVudEVkZ2VTdGFydCA8PSBzY3JvbGxpbmdFZGdlU3RhcnQgJiYgZWxlbWVudFNpemUgPD0gc2Nyb2xsaW5nU2l6ZSkgfHxcbiAgICAgICAgICAgIChlbGVtZW50RWRnZUVuZCA+PSBzY3JvbGxpbmdFZGdlRW5kICYmIGVsZW1lbnRTaXplID49IHNjcm9sbGluZ1NpemUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudEVkZ2VTdGFydCAtIHNjcm9sbGluZ0VkZ2VTdGFydCAtIHNjcm9sbGluZ0JvcmRlclN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBlbGVtZW50IGVkZ2UgQiBpcyBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBCIGFuZCBlbGVtZW50IGhlaWdodCBpcyBsZXNzIHRoYW4gc2Nyb2xsaW5nIGJveCBoZWlnaHRcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgIOKUj+KUgSDilIHilIEg4pSB4pSTICAgICAgICAg4pSP4pSBIOKUgeKUgSDilIHilJNcbiAgICAgICAgICpcbiAgICAgICAgICogIGZyb20gIOKUgyAgICAgIOKUgyAgICAgdG8gIOKUgyDilIzilIDilIDilJAg4pSDXG4gICAgICAgICAqICAgICAgICAgIOKUjOKUgOKUgOKUkCAgICAgICAgICAgICDilIIgIOKUglxuICAgICAgICAgKiAgICAgICAg4pSX4pSB4pSC4pSB4pSB4pSC4pSB4pSbICAgICAgICAg4pSX4pSB4pSU4pSB4pSB4pSY4pSB4pSbXG4gICAgICAgICAqICAgICAgICAgIOKUlOKUgOKUgOKUmFxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBlbGVtZW50IGVkZ2UgQSBpcyBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBBIGFuZCBlbGVtZW50IGhlaWdodCBpcyBncmVhdGVyIHRoYW4gc2Nyb2xsaW5nIGJveCBoZWlnaHRcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICAg4pSM4pSA4pSA4pSQXG4gICAgICAgICAqICAgICAgICAgIOKUgiAg4pSCXG4gICAgICAgICAqICAgICAgICAgIOKUgiAg4pSCICAgICAgICAgICAgIOKUjOKUgOKUgOKUkFxuICAgICAgICAgKiAgICAgICAg4pSP4pSB4pSC4pSB4pSB4pSC4pSB4pSTICAgICAgICAg4pSP4pSB4pSC4pSB4pSB4pSC4pSB4pSTXG4gICAgICAgICAqICAgICAgICAgIOKUgiAg4pSCICAgICAgICAgICAgIOKUgiAg4pSCXG4gICAgICAgICAqICBmcm9tICDilIMg4pSU4pSA4pSA4pSYIOKUgyAgICAgdG8gIOKUgyDilIIgIOKUgiDilINcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgIOKUglxuICAgICAgICAgKiAgICAgICAg4pSX4pSBIOKUgeKUgSDilIHilJsgICAgICAgICDilJfilIHilJTilIHilIHilJjilIHilJtcbiAgICAgICAgICpcbiAgICAgICAgICogSWYgZWxlbWVudCBlZGdlIEMgaXMgb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgQyBhbmQgZWxlbWVudCB3aWR0aCBpcyBncmVhdGVyIHRoYW4gc2Nyb2xsaW5nIGJveCB3aWR0aFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgICAgZnJvbSAgICAgICAgICAgICAgICAgdG9cbiAgICAgICAgICogICAgICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTICAgICAgICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJNcbiAgICAgICAgICogIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gICAgICAgICAqICDilIIgICAgIOKUgyAgICAg4pSCICAg4pSDICAgICAgIOKUgiDilIMgICAgICAgICDilINcbiAgICAgICAgICogIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAgICAgICAqICAgICAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUmyAgICAgICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGVsZW1lbnQgZWRnZSBEIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEQgYW5kIGVsZW1lbnQgd2lkdGggaXMgbGVzcyB0aGFuIHNjcm9sbGluZyBib3ggd2lkdGhcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICAgIGZyb20gICAgICAgICAgICAgICAgIHRvXG4gICAgICAgICAqICAgICAgICDilI8g4pSBIOKUgSDilIEg4pSBIOKUkyAgICAgICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTXG4gICAgICAgICAqICAgICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkCAgICAgICAgICAgICDilIzilIDilIDilIDilJBcbiAgICAgICAgICogICAgICAgIOKUgyAgICAgICDilIIg4pSDIOKUgiAgICAgICDilIMgICAgIOKUgiAgIOKUg1xuICAgICAgICAgKiAgICAgICAgICAgICAgICDilJTilIDilIDilIDilJggICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSYXG4gICAgICAgICAqICAgICAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUmyAgICAgICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoKGVsZW1lbnRFZGdlRW5kID4gc2Nyb2xsaW5nRWRnZUVuZCAmJiBlbGVtZW50U2l6ZSA8IHNjcm9sbGluZ1NpemUpIHx8IChlbGVtZW50RWRnZVN0YXJ0IDwgc2Nyb2xsaW5nRWRnZVN0YXJ0ICYmIGVsZW1lbnRTaXplID4gc2Nyb2xsaW5nU2l6ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50RWRnZUVuZCAtIHNjcm9sbGluZ0VkZ2VFbmQgKyBzY3JvbGxpbmdCb3JkZXJFbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxJbnRvVmlldyh0YXJnZXQsIHNjcm9sbGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBibG9jayA9IG9wdGlvbnMuYmxvY2ssIGlubGluZSA9IG9wdGlvbnMuaW5saW5lO1xuICAgICAgICAvLyBVc2VkIHRvIGhhbmRsZSB0aGUgdG9wIG1vc3QgZWxlbWVudCB0aGF0IGNhbiBiZSBzY3JvbGxlZFxuICAgICAgICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGdldFNjcm9sbGluZ0VsZW1lbnQoKTtcbiAgICAgICAgLy8gU3VwcG9ydCBwaW5jaC16b29taW5nIHByb3Blcmx5LCBtYWtpbmcgc3VyZSBlbGVtZW50cyBzY3JvbGwgaW50byB0aGUgdmlzdWFsIHZpZXdwb3J0XG4gICAgICAgIC8vIEJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB2aXN1YWxWaWV3cG9ydCB3aWxsIHJlcG9ydCB0aGUgbGF5b3V0IHZpZXdwb3J0IGRpbWVuc2lvbnMgb24gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoL0hlaWdodFxuICAgICAgICAvLyBhbmQgdmlld3BvcnQgZGltZW5zaW9ucyBvbiB3aW5kb3cuaW5uZXJXaWR0aC9IZWlnaHRcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvbW9iaWxlL3ZpZXdwb3J0czIuaHRtbFxuICAgICAgICAvLyBodHRwczovL2Jva2FuZC5naXRodWIuaW8vdmlld3BvcnQvaW5kZXguaHRtbFxuICAgICAgICB2YXIgdmlld3BvcnRXaWR0aCA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCAhPSBudWxsID8gdmlzdWFsVmlld3BvcnQud2lkdGggOiBpbm5lcldpZHRoO1xuICAgICAgICB2YXIgdmlld3BvcnRIZWlnaHQgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQgIT0gbnVsbCA/IHZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IGlubmVySGVpZ2h0O1xuICAgICAgICB2YXIgdmlld3BvcnRYID0gd2luZG93LnNjcm9sbFggIT0gbnVsbCA/IHdpbmRvdy5zY3JvbGxYIDogd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgICAgICB2YXIgdmlld3BvcnRZID0gd2luZG93LnNjcm9sbFkgIT0gbnVsbCA/IHdpbmRvdy5zY3JvbGxZIDogd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICB2YXIgX2EgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRhcmdldEhlaWdodCA9IF9hLmhlaWdodCwgdGFyZ2V0V2lkdGggPSBfYS53aWR0aCwgdGFyZ2V0VG9wID0gX2EudG9wLCB0YXJnZXRSaWdodCA9IF9hLnJpZ2h0LCB0YXJnZXRCb3R0b20gPSBfYS5ib3R0b20sIHRhcmdldExlZnQgPSBfYS5sZWZ0O1xuICAgICAgICAvLyBUaGVzZSB2YWx1ZXMgbXV0YXRlIGFzIHdlIGxvb3AgdGhyb3VnaCBhbmQgZ2VuZXJhdGUgc2Nyb2xsIGNvb3JkaW5hdGVzXG4gICAgICAgIHZhciB0YXJnZXRCbG9jayA9IGJsb2NrID09PSBcInN0YXJ0XCIgfHwgYmxvY2sgPT09IFwibmVhcmVzdFwiID8gdGFyZ2V0VG9wIDogYmxvY2sgPT09IFwiZW5kXCIgPyB0YXJnZXRCb3R0b20gOiB0YXJnZXRUb3AgKyB0YXJnZXRIZWlnaHQgLyAyOyAvLyBibG9jayA9PT0gJ2NlbnRlclxuICAgICAgICB2YXIgdGFyZ2V0SW5saW5lID0gaW5saW5lID09PSBcImNlbnRlclwiID8gdGFyZ2V0TGVmdCArIHRhcmdldFdpZHRoIC8gMiA6IGlubGluZSA9PT0gXCJlbmRcIiA/IHRhcmdldFJpZ2h0IDogdGFyZ2V0TGVmdDsgLy8gaW5saW5lID09PSAnc3RhcnQgfHwgaW5saW5lID09PSAnbmVhcmVzdFxuICAgICAgICB2YXIgX2IgPSBzY3JvbGxlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgaGVpZ2h0ID0gX2IuaGVpZ2h0LCB3aWR0aCA9IF9iLndpZHRoLCB0b3AgPSBfYi50b3AsIHJpZ2h0ID0gX2IucmlnaHQsIGJvdHRvbSA9IF9iLmJvdHRvbSwgbGVmdCA9IF9iLmxlZnQ7XG4gICAgICAgIHZhciBmcmFtZVN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShzY3JvbGxlcik7XG4gICAgICAgIHZhciBib3JkZXJMZWZ0ID0gcGFyc2VJbnQoZnJhbWVTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKTtcbiAgICAgICAgdmFyIGJvcmRlclRvcCA9IHBhcnNlSW50KGZyYW1lU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKTtcbiAgICAgICAgdmFyIGJvcmRlclJpZ2h0ID0gcGFyc2VJbnQoZnJhbWVTdHlsZS5ib3JkZXJSaWdodFdpZHRoLCAxMCk7XG4gICAgICAgIHZhciBib3JkZXJCb3R0b20gPSBwYXJzZUludChmcmFtZVN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCk7XG4gICAgICAgIHZhciBibG9ja1Njcm9sbCA9IDA7XG4gICAgICAgIHZhciBpbmxpbmVTY3JvbGwgPSAwO1xuICAgICAgICAvLyBUaGUgcHJvcGVydHkgZXhpc3RhbmNlIGNoZWNrcyBmb3Igb2Zmc2V0W1dpZHRofEhlaWdodF0gaXMgYmVjYXVzZSBvbmx5IEhUTUxFbGVtZW50IG9iamVjdHMgaGF2ZSB0aGVtLCBidXQgYW55IEVsZW1lbnQgbWlnaHQgcGFzcyBieSBoZXJlXG4gICAgICAgIC8vIEBUT0RPIGZpbmQgb3V0IGlmIHRoZSBcImFzIEhUTUxFbGVtZW50XCIgb3ZlcnJpZGVzIGNhbiBiZSBkcm9wcGVkXG4gICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IFwib2Zmc2V0V2lkdGhcIiBpbiBzY3JvbGxlciA/IHNjcm9sbGVyLm9mZnNldFdpZHRoIC0gc2Nyb2xsZXIuY2xpZW50V2lkdGggLSBib3JkZXJMZWZ0IC0gYm9yZGVyUmlnaHQgOiAwO1xuICAgICAgICB2YXIgc2Nyb2xsYmFySGVpZ2h0ID0gXCJvZmZzZXRIZWlnaHRcIiBpbiBzY3JvbGxlciA/IHNjcm9sbGVyLm9mZnNldEhlaWdodCAtIHNjcm9sbGVyLmNsaWVudEhlaWdodCAtIGJvcmRlclRvcCAtIGJvcmRlckJvdHRvbSA6IDA7XG4gICAgICAgIGlmIChzY3JvbGxpbmdFbGVtZW50ID09PSBzY3JvbGxlcikge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHZpZXdwb3J0IGxvZ2ljIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgb3IgZG9jdW1lbnQuYm9keSlcbiAgICAgICAgICAgIGlmIChibG9jayA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tTY3JvbGwgPSB0YXJnZXRCbG9jaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJsb2NrID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tTY3JvbGwgPSB0YXJnZXRCbG9jayAtIHZpZXdwb3J0SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmxvY2sgPT09IFwibmVhcmVzdFwiKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tTY3JvbGwgPSBhbGlnbk5lYXJlc3Qodmlld3BvcnRZLCB2aWV3cG9ydFkgKyB2aWV3cG9ydEhlaWdodCwgdmlld3BvcnRIZWlnaHQsIGJvcmRlclRvcCwgYm9yZGVyQm90dG9tLCB2aWV3cG9ydFkgKyB0YXJnZXRCbG9jaywgdmlld3BvcnRZICsgdGFyZ2V0QmxvY2sgKyB0YXJnZXRIZWlnaHQsIHRhcmdldEhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBibG9jayA9PT0gJ2NlbnRlcicgaXMgdGhlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICBibG9ja1Njcm9sbCA9IHRhcmdldEJsb2NrIC0gdmlld3BvcnRIZWlnaHQgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlubGluZSA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgaW5saW5lU2Nyb2xsID0gdGFyZ2V0SW5saW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5saW5lID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgICAgICAgaW5saW5lU2Nyb2xsID0gdGFyZ2V0SW5saW5lIC0gdmlld3BvcnRXaWR0aCAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmxpbmUgPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgICAgICBpbmxpbmVTY3JvbGwgPSB0YXJnZXRJbmxpbmUgLSB2aWV3cG9ydFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaW5saW5lID09PSAnbmVhcmVzdCcgaXMgdGhlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICBpbmxpbmVTY3JvbGwgPSBhbGlnbk5lYXJlc3Qodmlld3BvcnRYLCB2aWV3cG9ydFggKyB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydFdpZHRoLCBib3JkZXJMZWZ0LCBib3JkZXJSaWdodCwgdmlld3BvcnRYICsgdGFyZ2V0SW5saW5lLCB2aWV3cG9ydFggKyB0YXJnZXRJbmxpbmUgKyB0YXJnZXRXaWR0aCwgdGFyZ2V0V2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXBwbHkgc2Nyb2xsIHBvc2l0aW9uIG9mZnNldHMgYW5kIGVuc3VyZSB0aGV5IGFyZSB3aXRoaW4gYm91bmRzXG4gICAgICAgICAgICAvLyBAVE9ETyBhZGQgbW9yZSB0ZXN0IGNhc2VzIHRvIGNvdmVyIHRoaXMgMTAwJVxuICAgICAgICAgICAgYmxvY2tTY3JvbGwgPSBNYXRoLm1heCgwLCBibG9ja1Njcm9sbCArIHZpZXdwb3J0WSk7XG4gICAgICAgICAgICBpbmxpbmVTY3JvbGwgPSBNYXRoLm1heCgwLCBpbmxpbmVTY3JvbGwgKyB2aWV3cG9ydFgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGVhY2ggc2Nyb2xsaW5nIGZyYW1lIHRoYXQgbWlnaHQgZXhpc3QgYmV0d2VlbiB0aGUgdGFyZ2V0IGFuZCB0aGUgdmlld3BvcnRcbiAgICAgICAgICAgIGlmIChibG9jayA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tTY3JvbGwgPSB0YXJnZXRCbG9jayAtIHRvcCAtIGJvcmRlclRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJsb2NrID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tTY3JvbGwgPSB0YXJnZXRCbG9jayAtIGJvdHRvbSArIGJvcmRlckJvdHRvbSArIHNjcm9sbGJhckhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJsb2NrID09PSBcIm5lYXJlc3RcIikge1xuICAgICAgICAgICAgICAgIGJsb2NrU2Nyb2xsID0gYWxpZ25OZWFyZXN0KHRvcCwgYm90dG9tLCBoZWlnaHQsIGJvcmRlclRvcCwgYm9yZGVyQm90dG9tICsgc2Nyb2xsYmFySGVpZ2h0LCB0YXJnZXRCbG9jaywgdGFyZ2V0QmxvY2sgKyB0YXJnZXRIZWlnaHQsIHRhcmdldEhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBibG9jayA9PT0gJ2NlbnRlcicgaXMgdGhlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICBibG9ja1Njcm9sbCA9IHRhcmdldEJsb2NrIC0gKHRvcCArIGhlaWdodCAvIDIpICsgc2Nyb2xsYmFySGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmxpbmUgPT09IFwic3RhcnRcIikge1xuICAgICAgICAgICAgICAgIGlubGluZVNjcm9sbCA9IHRhcmdldElubGluZSAtIGxlZnQgLSBib3JkZXJMZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5saW5lID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgICAgICAgaW5saW5lU2Nyb2xsID0gdGFyZ2V0SW5saW5lIC0gKGxlZnQgKyB3aWR0aCAvIDIpICsgc2Nyb2xsYmFyV2lkdGggLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5saW5lID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgaW5saW5lU2Nyb2xsID0gdGFyZ2V0SW5saW5lIC0gcmlnaHQgKyBib3JkZXJSaWdodCArIHNjcm9sbGJhcldpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaW5saW5lID09PSAnbmVhcmVzdCcgaXMgdGhlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICBpbmxpbmVTY3JvbGwgPSBhbGlnbk5lYXJlc3QobGVmdCwgcmlnaHQsIHdpZHRoLCBib3JkZXJMZWZ0LCBib3JkZXJSaWdodCArIHNjcm9sbGJhcldpZHRoLCB0YXJnZXRJbmxpbmUsIHRhcmdldElubGluZSArIHRhcmdldFdpZHRoLCB0YXJnZXRXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHNjcm9sbGVyLnNjcm9sbExlZnQsIHNjcm9sbFRvcCA9IHNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBzY3JvbGwgY29vcmRpbmF0ZXMgYXJlIG5vdCBvdXQgb2YgYm91bmRzIHdoaWxlIGFwcGx5aW5nIHNjcm9sbCBvZmZzZXRzXG4gICAgICAgICAgICBibG9ja1Njcm9sbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbFRvcCArIGJsb2NrU2Nyb2xsLCBzY3JvbGxlci5zY3JvbGxIZWlnaHQgLSBoZWlnaHQgKyBzY3JvbGxiYXJIZWlnaHQpKTtcbiAgICAgICAgICAgIGlubGluZVNjcm9sbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbExlZnQgKyBpbmxpbmVTY3JvbGwsIHNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gd2lkdGggKyBzY3JvbGxiYXJXaWR0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IGJsb2NrU2Nyb2xsLFxuICAgICAgICAgICAgbGVmdDogaW5saW5lU2Nyb2xsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF0Y2hlcyB0aGUgJ3Njcm9sbEludG9WaWV3JyBtZXRob2Qgb24gdGhlIEVsZW1lbnQgcHJvdG90eXBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGF0Y2hFbGVtZW50U2Nyb2xsSW50b1ZpZXcoKSB7XG4gICAgICAgIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3ID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRPcHRpb25zID0gYXJnID09IG51bGwgfHwgYXJnID09PSB0cnVlXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIGlubGluZTogXCJuZWFyZXN0XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBhcmcgPT09IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2s6IFwiZW5kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmxpbmU6IFwibmVhcmVzdFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBhcmc7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBuZWFyZXN0IGFuY2VzdG9yIHRoYXQgY2FuIGJlIHNjcm9sbGVkXG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoZmluZE5lYXJlc3RBbmNlc3RvcnNXaXRoU2Nyb2xsQmVoYXZpb3IodGhpcyksIDIpLCBhbmNlc3RvcldpdGhTY3JvbGwgPSBfYVswXSwgYW5jZXN0b3JXaXRoU2Nyb2xsQmVoYXZpb3IgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBiZWhhdmlvciA9IG5vcm1hbGl6ZWRPcHRpb25zLmJlaGF2aW9yICE9IG51bGwgPyBub3JtYWxpemVkT3B0aW9ucy5iZWhhdmlvciA6IGFuY2VzdG9yV2l0aFNjcm9sbEJlaGF2aW9yO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGJlaGF2aW9yIGlzbid0IHNtb290aCwgc2ltcGx5IGludm9rZSB0aGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gYW5kIGRvIG5vIG1vcmVcbiAgICAgICAgICAgIGlmIChiZWhhdmlvciAhPT0gXCJzbW9vdGhcIikge1xuICAgICAgICAgICAgICAgIC8vIEFzc2VydCB0aGF0ICdzY3JvbGxJbnRvVmlldycgaXMgYWN0dWFsbHkgZGVmaW5lZFxuICAgICAgICAgICAgICAgIGlmIChFTEVNRU5UX09SSUdJTkFMX1NDUk9MTF9JTlRPX1ZJRVcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBFTEVNRU5UX09SSUdJTkFMX1NDUk9MTF9JTlRPX1ZJRVcuY2FsbCh0aGlzLCBub3JtYWxpemVkT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaW52b2tlICdzY3JvbGxUbycgaW5zdGVhZCBhbmQgcHJvdmlkZSB0aGUgc2Nyb2xsIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IGNvbXB1dGVTY3JvbGxJbnRvVmlldyh0aGlzLCBhbmNlc3RvcldpdGhTY3JvbGwsIG5vcm1hbGl6ZWRPcHRpb25zKSwgdG9wXzEgPSBfYi50b3AsIGxlZnQgPSBfYi5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBnZXRPcmlnaW5hbFNjcm9sbE1ldGhvZEZvcktpbmQoXCJzY3JvbGxUb1wiLCB0aGlzKS5jYWxsKHRoaXMsIGxlZnQsIHRvcF8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3JXaXRoU2Nyb2xsLnNjcm9sbFRvKF9fYXNzaWduKHsgYmVoYXZpb3I6IGJlaGF2aW9yIH0sIGNvbXB1dGVTY3JvbGxJbnRvVmlldyh0aGlzLCBhbmNlc3RvcldpdGhTY3JvbGwsIG5vcm1hbGl6ZWRPcHRpb25zKSkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBPbiBJRTExLCBIVE1MRWxlbWVudCBoYXMgaXRzIG93biBkZWNsYXJhdGlvbiBvZiBzY3JvbGxJbnRvVmlldyBhbmQgZG9lcyBub3QgaW5oZXJpdCB0aGlzIGZyb20gdGhlIHByb3RvdHlwZSBjaGFpbiwgc28gd2UnbGwgbmVlZCB0byBwYXRjaCB0aGF0IG9uZSB0b28uXG4gICAgICAgIGlmIChIVE1MRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXcgIT0gbnVsbCAmJiBIVE1MRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXcgIT09IEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXcgPSBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlldztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBFTEVNRU5UX09SSUdJTkFMX1NDUk9MTF9UT1BfU0VUX0RFU0NSSVBUT1IgPSBVTlNVUFBPUlRFRF9FTlZJUk9OTUVOVFxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRWxlbWVudC5wcm90b3R5cGUsIFwic2Nyb2xsVG9wXCIpLnNldDtcblxuICAgIC8qKlxuICAgICAqIFBhdGNoZXMgdGhlICdzY3JvbGxUb3AnIHByb3BlcnR5IGRlc2NyaXB0b3Igb24gdGhlIEVsZW1lbnQgcHJvdG90eXBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGF0Y2hFbGVtZW50U2Nyb2xsVG9wKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWxlbWVudC5wcm90b3R5cGUsIFwic2Nyb2xsVG9wXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fYWRqdXN0aW5nU2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVMRU1FTlRfT1JJR0lOQUxfU0NST0xMX1RPUF9TRVRfREVTQ1JJUFRPUi5jYWxsKHRoaXMsIHNjcm9sbFRvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhbmRsZVNjcm9sbE1ldGhvZCh0aGlzLCBcInNjcm9sbFRvXCIsIHRoaXMuc2Nyb2xsTGVmdCwgc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgRUxFTUVOVF9PUklHSU5BTF9TQ1JPTExfTEVGVF9TRVRfREVTQ1JJUFRPUiA9IFVOU1VQUE9SVEVEX0VOVklST05NRU5UXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFbGVtZW50LnByb3RvdHlwZSwgXCJzY3JvbGxMZWZ0XCIpLnNldDtcblxuICAgIC8qKlxuICAgICAqIFBhdGNoZXMgdGhlICdzY3JvbGxMZWZ0JyBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9uIHRoZSBFbGVtZW50IHByb3RvdHlwZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhdGNoRWxlbWVudFNjcm9sbExlZnQoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbGVtZW50LnByb3RvdHlwZSwgXCJzY3JvbGxMZWZ0XCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2FkanVzdGluZ1Njcm9sbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFTEVNRU5UX09SSUdJTkFMX1NDUk9MTF9MRUZUX1NFVF9ERVNDUklQVE9SLmNhbGwodGhpcywgc2Nyb2xsTGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhbmRsZVNjcm9sbE1ldGhvZCh0aGlzLCBcInNjcm9sbFRvXCIsIHNjcm9sbExlZnQsIHRoaXMuc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgcG9seWZpbGxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXRjaCgpIHtcbiAgICAgICAgLy8gRWxlbWVudC5wcm90b3R5cGUgbWV0aG9kc1xuICAgICAgICBwYXRjaEVsZW1lbnRTY3JvbGwoKTtcbiAgICAgICAgcGF0Y2hFbGVtZW50U2Nyb2xsQnkoKTtcbiAgICAgICAgcGF0Y2hFbGVtZW50U2Nyb2xsVG8oKTtcbiAgICAgICAgcGF0Y2hFbGVtZW50U2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgLy8gRWxlbWVudC5wcm90b3R5cGUgZGVzY3JpcHRvcnNcbiAgICAgICAgcGF0Y2hFbGVtZW50U2Nyb2xsTGVmdCgpO1xuICAgICAgICBwYXRjaEVsZW1lbnRTY3JvbGxUb3AoKTtcbiAgICAgICAgLy8gd2luZG93IG1ldGhvZHNcbiAgICAgICAgcGF0Y2hXaW5kb3dTY3JvbGwoKTtcbiAgICAgICAgcGF0Y2hXaW5kb3dTY3JvbGxCeSgpO1xuICAgICAgICBwYXRjaFdpbmRvd1Njcm9sbFRvKCk7XG4gICAgICAgIC8vIE5hdmlnYXRpb25cbiAgICAgICAgY2F0Y2hOYXZpZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXMgdHJ1ZSBpZiB0aGUgYnJvd3NlciBuYXRpdmVseSBzdXBwb3J0cyB0aGUgRWxlbWVudC5wcm90b3R5cGUuW3Njcm9sbHxzY3JvbGxUb3xzY3JvbGxCeXxzY3JvbGxJbnRvVmlld10gbWV0aG9kc1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHZhciBTVVBQT1JUU19FTEVNRU5UX1BST1RPVFlQRV9TQ1JPTExfTUVUSE9EUyA9IFVOU1VQUE9SVEVEX0VOVklST05NRU5UXG4gICAgICAgID8gZmFsc2VcbiAgICAgICAgOiBcInNjcm9sbFwiIGluIEVsZW1lbnQucHJvdG90eXBlICYmIFwic2Nyb2xsVG9cIiBpbiBFbGVtZW50LnByb3RvdHlwZSAmJiBcInNjcm9sbEJ5XCIgaW4gRWxlbWVudC5wcm90b3R5cGUgJiYgXCJzY3JvbGxJbnRvVmlld1wiIGluIEVsZW1lbnQucHJvdG90eXBlO1xuXG4gICAgaWYgKCFVTlNVUFBPUlRFRF9FTlZJUk9OTUVOVCAmJiAoIVNVUFBPUlRTX1NDUk9MTF9CRUhBVklPUiB8fCAhU1VQUE9SVFNfRUxFTUVOVF9QUk9UT1RZUEVfU0NST0xMX01FVEhPRFMpKSB7XG4gICAgICAgIHBhdGNoKCk7XG4gICAgfVxuXG59KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/scroll-behavior-polyfill/dist/index.js\n");

/***/ })

}]);